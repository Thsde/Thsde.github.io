[{"title":"随笔_","date":"2017-03-10T15:28:23.000Z","path":"2017/03/10/2017年03月10日23-27-37/","text":"恰逢周五，家里打电话来，又再催了家里把之前的两辆旧的自行车卖了，暑假的时候打算买辆新的自行车骑行回家，望可成行。 今天看公号文章的时候，看到一段挺有感觉的，摘自昌记负食的《考研失败以后的150天》 为什么我从来不肯说，我成绩差是因为我努力在辩论和社团活动中体验人生，我考研是为了完成自己在学术上的梦想，我找工作是因为我对贵司的热爱呢？ 因为本来就不是这样啊。 我成绩差就是因为懒，考研就是为了逃避就业，找工作就是因为想赚钱，想吃涮羊肉。 与君共勉吧！","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++中const的用法","date":"2017-03-10T04:30:45.000Z","path":"2017/03/10/const/","text":"const变量const又叫做const限定符，用关键字const对变量的类型加以限定，可以使得变量的值不能被改变。 123const int i = 1; //正确：编译时初始化const int i = get_size(); //正确：运行时初始化const int k; //错误：k是一个未经初始化的常量 没有初始化的常量变量编译错误其实很好理解，因为经过const限定之后变量的值已经无法改变，如果没有初始化那么这个变量的值不确定，且之后其值不能被改变。 const引用const引用称为对常量的引用，简称为“常量引用”,顾名思义，就是这个对象是一个引用，而且这个对象经过const限定符作用之后，对象的值不能被改变。12345678int main() &#123; const int c1 = 10; const int &amp;r1 = c1; int c2 = 4; const int &amp;r2 = c2; c2 = 5; cout &lt;&lt; r2 &lt;&lt; endl;&#125; 如上所示，常量引用r1,r2是一个常量，而同时，因为const的限制，r1和r2的值不能改变，所以通过r1和r2修改c1和c2的值也就不可能，但是c2因为没有const的限制，可以通过c2修改自身的值。 引用的类型必须与其引用对象的类型一致，但存在例外。一种则是允许常量引用绑定一个非常量的对象，但是不能通过该常量引用改变绑定对象的值，此种情况上面已经出现，不在赘述。另一种是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。12double dval = 3.14;const int &amp;ri = dval; 上述代码是合法的操作c机制是12const int temp = dval;const int &amp;ri = temp; 也就是先将dval转化为整型，注意，其中的temp是临时量，所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。而如果ri不是常量，即：12double dval = 3.14;int &amp;r1 = dval; 此时编译器会报错，错误如下：12error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’int &amp;r1 = dval; 指针和const与引用一样，也可以令指针指向常量或非常量，类似于常量引用，指向常量的指针（不是常量指针）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：1234const double pi = 3.14;double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个常量*cptr = 42; //错误：不能给*cptr赋值 同样，指针的类型必须与其所指对象的类型一致，但是与引用一样，存在例外，允许一个指向常量的指针指向一个非常量的对象：12double dval = 3.14;const double *cptr = &amp;dval; //不能通过cptr改变dval的值 指针是对象而引用不是，所以允许把指针本身定为常量。常量指针必须初始化，一旦初始化完成，则指针的值不能被修改。1234int errNumb = 0;int *const curErr = &amp;errNumb;const double pi = 3.14;const double *const pip = &amp;pi; 将号放在const关键字之前用以说明指针是一个常量，不变的是指针本身的值而非指向的那个值。从右向左阅读解析，如上面代码第二行中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是，意思是curErr是一个常量指针。最后，声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。同理，我们可以看出pip是一个常量指针，指向的对象是一个双精度浮点型常量。 指向常量的指针和常量指针的对比指向常量的指针是指指针指向的值是一个常量（存在上述的例外），这就说明指针的值是可以被改变的，而常量指针是指指针本身是一个常量，但是指针指向的值不一定是常量。 顶层const指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用；底层const则与指针和引用等复合类型的基本类型部分有关。123456int i = 0;int *const pl = &amp;i; //顶层const int ci = 42; //顶层const int *p2 = &amp;ci; //底层const int *const p3 = p2; //左边是底层，右边是顶层const int &amp;r = ci; //用于声明引用的const都是底层const 常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：1234const int max_files = 20; //是常量表达式const int limit = max_files + 1; //是常量表达式int staff_size = 27; //不是常量表达式，因为只是int类型const int sz = get_size(); //不是，sz的值要到运行时确定","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Hello World","date":"2017-03-10T02:44:44.830Z","path":"2017/03/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"C和C++中声明和定义的区别","date":"2017-03-09T16:07:31.000Z","path":"2017/03/10/test-1/","text":"声明使得名字为程序所知，而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与声明相同，然而定义还申请了存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量123extern int i； //声明i而不是定义iint j; //声明并且定义了j 任何包含了显式初始化的声明即成为定义。 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i = 3;&#125; 123error: ‘i’ has both ‘extern’ and initializerextern int i = 3; ^ 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到变量的文件必须对其进行声明，却绝对不能重复定义。 正确的用法如下： test.hpp12345#include &lt;iostream&gt;using namespace std;int i = 2; test.cpp12345678910111213#include &lt;iostream&gt;#include \"test.hpp\"using namespace std;extern int i;int main() &#123; cout &lt;&lt; i; i = 1; cout &lt;&lt; endl &lt;&lt; i; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]