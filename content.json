[{"title":"GDB调试","date":"2017-03-15T05:13:25.000Z","path":"2017/03/15/GDB调试/","text":"文中代码部分及部分讲解转载自陈皓gdb教程相关博客 What is GDB? GDB, the GNU Project debugger, allows you to see what is going on `inside’ another program while it executes – or what another program was doing at the moment it crashed.GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act:Start your program, specifying anything that might affect its behavior.Make your program stop on specified conditions.Examine what has happened, when your program has stopped.Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.The program being debugged can be written in Ada, C, C++, Objective-C, Pascal (and many other languages). Those programs might be executing on the same machine as GDB (native) or on another machine (remote). GDB can run on most popular UNIX and Microsoft Windows variants. 简单来说，GDB就是一个DEBUG的工具 GDB 安装Linux系统下：终端运行如下命令1sudo apt-get install gdb Windows系统下：下载MinGw或者TDM-GCC然后配置一下环境变量就可以在CMD中使用了。安装完成后输入：1gdb -v 出现如下提示表示安装成功：1234567891011121314GNU gdb (Debian 7.11.1-2) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\". 编译说明要使用gdb调试程序，必须在进行编译时（g++或gcc）加入-g选项进行编译：1g++ test.cpp -g 运行GDBlinux系统下编译链接默认生成a.out文件，所以在a.out文件所在目录下执行：1gdb a.out windows系统下默认生成a.exe，同理在a.exe文件所在目录下执行：1gdb a.exe 调试实例及部分简单调试命令test.c:1234567891011121314151617181920#include &lt;stdio.h&gt;int func(int n) &#123; int sum=0,i; for(i=1; i&lt;=n; i++) &#123; sum+=i; &#125; return sum;&#125;int main() &#123; int i; long result = 0; for(i=1; i&lt;=100; i++) &#123; result += i; &#125; printf(\"result[1-100] = %d \\n\", result ); printf(\"result[1-250] = %d \\n\", func(250) );&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960(gdb) b 12 //设置断点，break的缩写，在源程序第12行处。Breakpoint 1 at 0x6e6: file test.c, line 12.(gdb) b func //设置断点，在函数func()入口处。Breakpoint 2 at 0x8048456: file tst.c, line 3.(gdb) info b //查看断点信息Num Type Disp Enb Address What1 breakpoint keep y 0x00000000000006e6 in main at test.c:122 breakpoint keep y 0x00000000000006b7 in func at test.c:4(gdb) r //运行程序，run的缩写Starting program:Breakpoint 1, main () at test.c:1313 long result = 0;(gdb) n //next的缩写，执行下一步14 for(i=1; i&lt;=100; i++) &#123;(gdb) n15 result += i;(gdb) n14 for(i=1; i&lt;=100; i++) &#123;(gdb) n15 result += i;(gdb) c //继续运行程序，continue命令简写。Continuing.result[1-100] = 5050 //程序输出。Breakpoint 2, func (n=250) at tst.c:54 int sum=0,i;(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p i //打印变量i的值，print命令简写。$1 = 134513808(gdb) n6 sum+=i;(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p sum$2 = 1(gdb) n6 sum+=i;(gdb) p i$3 = 2(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p sum$4 = 3(gdb) bt //查看函数堆栈。#0 func (n=250) at tst.c:5#1 0x080484e4 in main () at tst.c:24#2 0x400409ed in __libc_start_main () from /lib/libc.so.6(gdb) finish //退出函数。Run till exit from #0 func (n=250) at tst.c:50x080484e4 in main () at tst.c:2424 printf(\"result[1-250] = %d /n\", func(250) );Value returned is $6 = 31375(gdb) c //继续运行。Continuing.result[1-250] = 31375 //程序输出。Program exited with code 027. //程序退出，调试结束。(gdb) q //退出gdb。 step（简写为s）命令和next命令都是执行下一步，不同的是step命令会进入函数的内部，而next命令则是会直接执行完函数，然后在该函数的下一步等待如在上面代码的17行加上func(30)并进行gdb调试；1234Breakpoint 1, main () at test.c:1717 func(30);(gdb) n18 printf(\"result[1-100] = %d \\n\", result ); 使用next命令直接跳到18行等待12345678910Breakpoint 1, main () at test.c:1717 func(30);(gdb) sfunc (n=30) at test.c:44 int sum=0,i;(gdb) s5 for(i=1; i&lt;=n; i++) &#123;(gdb) s6 sum+=i;(gdb) s 可以看到，使用s进入到了func函数的内部","tags":[{"name":"基本技术","slug":"基本技术","permalink":"http://yoursite.com/tags/基本技术/"}]},{"title":"指令集","date":"2017-03-13T15:01:26.000Z","path":"2017/03/13/instruction/","text":"Concept: 指令集是CPU可以执行的指令的集合，是计算机设计者和计算机程序员之间的接口，CPU的操作由其可以执行的指令集决定。 Elements of an Instruction Operation code(Opcode) 操作码 表示该指令进行的操作的类型 Source Operand Reference 源操作数 该操作所需输入的操作数 Result Operand Reference 目标操作数 操作产生的需要存储的结果 Next Instruction Reference 下一条指令地址 告诉CPU当前指令完成后下一条指令的地址 Instruction Representation 机器码：指令(无论操作数还是操作码)都是无差别地以二进制的形式存储 汇编语言：操作码用缩写的形式(助记符)表示，说明该指令进行的操作的类型，操作数也以相应的符号来表示 Instruction Types Data processing(数据处理) Data Storage(数据存储) Data movement(I/O) Control(控制) Instruction Set Design Operation repertoire(操作类型储备) How many ops? What can they do? How complex are they? Data types(数据类型) Insturctoin formats(指令格式) Length of opcode field Number of addresses Registers Number of CPU registers availiable Which operations can be performed on which registers? Addressing modes(寻址模式) Types of Operand Addresses Numbers Charcters Logical Data Types of Operation Data Transfer(数据传输) Arithmetic(算术运算) Logical(逻辑运算) Conversion(转换):转换数据的形式，如十进制转为二进制 I/O System Control Transfer of Control(控制转换)：例如跳转，子程序调用 Byte Order(位元组顺序) little-endian(小端规则):LSB(最低有效位，即最左边的位)存储在低位的地址之中。 big-endian(大端规则):LSB存储在高位的地址之中。 0x12345678存储左边为大端规则，右边为小端规则 Addressing Modes(寻址模式)根据对操作数和/或地址的使用不同加以区分的多种寻址方式中的一种说明如何获取指令中操作数和下一条指令,经常不止一种寻址方式被使用，不同的操作码使用不同的寻址方式，指令中的方式字段说明寻址的方式。 Immediate (立即寻址)：操作数是位于指令自身中的常数 Direct (直接寻址)：指令中存储的是操作数的地址 Indirect (间接寻址)：指令中存储的是操作数的地址的地址 Register (寄存器寻址)：操作数是寄存器 Register Indirect (寄存器间接寻址)：对寄存器访问取得操作数地址 Displacement (Indexed) (偏移寻址)：操作数在内存中，其地址是指令中基址寄存器和常数的和 Stack (堆栈寻址)：详情点击 速度排序：立即寻址 &gt; 寄存器寻址 &gt; 直接寻址 &gt; 寄存器间接寻址 &gt; 间接寻址 RISC vs CISCCISC：复杂指令集，有大量的变长的，复杂结构的指令，可以完成复杂的任务RISC：精简指令集，减少了大量非必须指令且简化了剩余的指令使其执行速度加快。特征如下： 所有指令定长（4个字节），通过补0实现使CPU能够快速解码 指令只能从内存加载到寄存器或从寄存器存储到内存","tags":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://yoursite.com/tags/计算机组成/"}]},{"title":"进程","date":"2017-03-12T14:10:43.000Z","path":"2017/03/12/进程/","text":"Process Concept简单来说，进程就是指正在执行的程序，执行并不一定是在运行。一个进程包括以下三个方面 程序计数器 (program counter) 堆栈段 (stack) 数据段 (data section) 程序包括代码段、当前活动（通过PC的值和处理器寄存器的内容来表示）、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）和数据段（包括全局变量），可能还包括堆(heap)，进程在运行期间动态分配的内存。 如下图所示： Process State new(创建): The proces is being created running(运行): Instructions are being executed waiting(等待): The process is waiting for some event to occur ready(就绪): The process is waiting to be assigned to a processor terminated(终止): The process has finished execution 进程五状态表： Process Control Block(PCB)每个进程在操作系统内用进程控制块来表示，它包含许多与一个特定进程相关的信息。 Process state: 包括创建、就绪、运行、等待、停止等 Program counter: 表示进程要执行的下个指令的地址 CPU registers CPU scheduling information Memory-management information Accounting information I/O status information Process Scheduling为了最大效率地利用CPU，进程调度选择一个可用的进程到CPU上执行。 Process Scheduling Queues(调度队列) Job queue – set of all processes in the system Ready queue – set of all processes residing in main memory, ready and waiting to execute Device queues – set of processes waiting for an I/O device Processes migrate(迁移) among the various queues Scheduler(调度程序)进程在其生命周期中会在各种调度队列之间迁移。为了调度，操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的调度程序来执行的。 长期调度程序(long-term scheduler)：又叫做作业调度程序(job scheduler)从存放”进程”的大容量存储设备的缓存池中选择进程，并加载进内存准备执行。 短期调度程序(short-term scheduler)：又叫做CPU调度程序，从准备执行的进程中选择进程，并为之分配CPU。 中期调度程序(medium-term scheduler)：核心思想是能将进程从内存中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案称为交换(swapping) 长期调度程序被调用的频率比较低，短期调度程序被调用的频率比较高 Context Switch(上下文切换)将CPU切换到另一个进程需要保存当前进程的状态（保存在PCB中）并恢复另一个进程的状态，这一任务称为上下文切换 Operations on Processes(进程操作)进程创建(Process Creation)进程在其执行过程中，能通过创建进程系统调用创建多个新进程。创建进程称为父进程，而新进程称为子进程。每个新进程可以在创建其他进程，从而行程了进程树。 创建进程的两种可能： 1、父进程与子进程并发(concurrently)执行2、父进程等待，直到某个或全部子进程执行完 新进程的地址空间的两种可能： 1、子进程是父进程的复制品（具有和父进程相同的程序和数据）2、子进程装入另一个新程序 资源共享： 1、父进程和子进程共享所有资源2、父进程分配一部分资源给子进程3、父进程和子进程没有共享资源 进程终止(Process Termination)当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止。这是，进程可以返回状态值到父进程。所有进程资源被操作系统释放。父进程终止子进程的原因： 1、子进程使用了超过它被分配的一些资源2、分配给子进程的任务已不再需要3、父进程退出，如果父进程退出，操作系统不允许子进程继续，这称为级联终止(cascading termination) Cooperating Processes(协作进程)生产者-消费者问题是协作进程的通用范例。生产者进程产生信息以供消费者进程消费。 为了允许生产者进程和消费者进程能并发执行，必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内，当消费者使用一项时，生产者能产生另一项。生产者和消费者必须同步，以免消费者消费一个没有生产出来的项。 缓冲主要存在两种： 1、无限缓冲(unbounded-buffer)：对缓冲大小没有限制。消费者可能不得不等待新的项，但生产者总是可以产生新项2、有限缓冲(bounded-buffer)：缓冲固定，若缓冲为空，消费者必须等待；若缓冲为满，生产者必须等待 Interprocess Communication(进程间通信IPC)通信模型： 共享内存系统通过生产者-消费者问题，协作进程加以实现 消息传递系统消息传递是由操作系统提供机制，让协作进程能通过消息传递工具来进行通信。消息传递工具提供至少两种操作：发送和接受。send(),receive()操作方法： 直接或间接通信 同步或异步通信 自动或显式缓冲 直接或间接通信对于直接通信，需要通信的每个进程明确地命名通信的接受者或发送者。 直接通信的通信线路具有如下特点： 在需要通信的每队进程之间自动建立线路。进程只需要知道相互通信的标识符。 一个线路只与两个进程相关。 每队进程之间只有一个线路。 这种方案展示了对称寻址，即发送和接受进程必须命名对方以便通信。另外有非对称寻址，即只要发送者命名接受者，而接受者不需要命名发送者。 间接通信：通过邮箱或端口来发送和接受信息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一的标识符。间接通信的通信线路具有如下属性： 只有在两个进程共享一个邮箱时，才能建立通信线路。 一个线路可以与两个或更多的进程相关联 两个通信进程之间可有多个不同的线路，每个线路对应于一个邮箱 同步和异步通信消息传递可以是阻塞(block)或非阻塞 —— 也称为同步或异步 阻塞send：发送进程阻塞，知道消息被接收或被邮箱所接收 非阻塞send：发送进程发送消息并继续操作 阻塞receive：接受者阻塞，直到有消息可用 非阻塞receive：接受者收到一个有效消息或空消息 自动或显式缓冲不管通信是直接的或是间接的，通信进程所交换的消息都驻留在临时队列中。 零容量：线路中不能有任何消息处于等待，必须阻塞发送，知道接收者接收到信息。 有限容量：队列长度为有限的n，最多只能有n个消息驻留其中，若未满，可以接收新消息，且发送者可继续执行不必等待。若容量已满，必须阻塞发送直到队列中的空间可用为之。 无限容量：队列长度无线，从不阻塞发送者 零容量情况称为没有缓冲的消息系统，其他情况称为自动缓冲。 Communication in Client-Server","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"随笔_","date":"2017-03-11T14:32:03.000Z","path":"2017/03/11/2017年03月11日22-31-58/","text":"Welcome to my blog, enter password to read. Decrypt U2FsdGVkX19P7Wp3wiCrPZqoUlpWKizLJBghCghW0/v7bcm3y95WAqLwlZ6LucOd2gtaLzOEX7LV4VycR2MzpXZlsIJq6g5yji1g34LzYpTmtnQdOO2ZCS2Dp1vBjHVJeYDuQgLxwpvZJxpjoJAJkZ5DxZPpK+gfc880bt29HaxmkExq2ypo/fgwDmmRKfRcTtWdG7mU5PV9DgQ6BiU0iReRWNEgaQtuAiIHW3kFAbmFB104N8vBxMVF/CsYL386AqGm8yDh32R5/FSvYOdlXUSxRH+/CeCVUOrk530KSpwtnavQLq8Ay53RmkWh/sA3c2Y3jVKaIWOy1ffqpZcuK2PbibIHicoSTI78dFPeSFyy6+iDp9S2q6DR74IiFzmTg0V9aaRhpix6gRv9GcpKFQzBnzOxuiYQtzSiiyjXVH81LO5gxbP6ebh0PzlreJa78oRKs3c3XQyDF0atWYgyg02lDE5wKI62s6I0vaWlYknZRaCiHXd2Woo7SZEQbnAGMWvaWdKEN2sJBd150NeWF0Npi2DLzfPonMFFEUr/wiKoaAa96Jhyytb/71UISLL6ZvZ+B/AByvnjkZXwnyCFv5eReTNS/0tsilfRyk4sXxyPbqG6Lc5ht/0mXiKEGfoMTWZ/tFCEOJN0/IJrQqJ/YOn+exAse5WlKJwZe2d5EiM5Ts33CHijy/h3wDrQjRX/9q/K44GBeJ0gh3aXhTr01rpUITX18/1t1YdVcOASn5BFVs0mD4lmleqPullrfiIdGji0p6Hn5OrCmjPyowBg9qg2mKXTBxM0G7OIjvxo7/iJPIdYjU5UAHi91z+GlpSH+sXl8DILsYssm/jE4Q5jmle/WKgrPg5paeV1Ghl3fEVJpw2Wcr1twN4qNVGzM80RFQmoEO4352ie9TWBAzwBpOPaWJb/cMz6mM8SALDoRWAhkmRHk+8DmpoMvtY8VxaXTO/Ny9t3OrA1Aq1m5+emQi/juUxh7gPNZTgCkzceFtj8nYHvmAbGV/WpWtyRAUA/2FDuzU8EE8E6kIMk7IcSFapMRUqHgUNcopZpvpJHKPsu2EMTCIyu4rTqdCmL6q7ZDHlLaHMveWwu1Qx5cZC5lFiOiniK1EMnCuWLq05hAQSM0hrTbqmR1U4zGfKCKB7KlTuKSzB6/0FZPUaDIcM3jfla/kDTtyAdRwTWw7COcYEMUbCpi+CzP1TpS1wdOj+I212PzjKhnyz1VnbA2QpB1kDk3TJel06XkJca1JKnHOgFdK/UdgIfvIQk642U8ewxttjObnIZ7HwWlfkPEjdyIy2Hjy7J5bgQa3nFl4v6G3ewsVkDoMqi6uGvAyod5B9sBHg+b9aFhhtyUPc+9IDb29nXhKLpC2pj08ZBf6bbZLWjiKL1HGBaA80nyVL1pIRiJtSOPPN2WVKpY8zQn7O+iKHkXO/9PRfii+Tyttqpn2OWDRtKamf19xYd4Xahkcme1ntwBflRkeFKHn3ubX60o4svETWjdGRm50T5xm9XVDwppf3ks3oJi4svXKCMzLfIC+OpFXmB9M+E2zDtYEPrS6R1zeySwpUivFYPExU1lSPJiwgat6q+hpQrz69MRJ+YzPpXm553qbfiWNwvRRvoQKFbP1Y628+9JaG+aYVlsMts98lw49fPYiUxBHNXgjdByi+j6FyHnJr8/QwjplJdiJVDvSr8Icc4iMK/O5FPxCMBIgPplGkp2tUcGKDmgzCr7ca3xA6Fw1gc0afr0NvWjvZqhUtfdqfvAC4zK7oCNRmXPksI66ZabiDI96sDHHMLrl5LD6PqVUrQlKXMflzJalmu26KzQcecqd8PEBkqA9cltuYdchhr8ND1oPK28Qe02rodZ7tonGN6CXE29FYPuPBe0POFJvhwslyJqP1NP0x0Jj5rlvcobyHTwhVxUHMC","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++ Function","date":"2017-03-11T07:34:55.000Z","path":"2017/03/11/function/","text":"函数定义：一个典型的函数定义包括以下部分：返回类型(return type)、函数名、由形参(parameter)组成的列表、函数体(function body)。 函数声明：和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。如果一个函数永远不会被用到，允许只有声明，没有定义。函数的声明和函数的定义很类似，唯一的区别是函数声明无需函数体。由于不包含函数体，形参的名字也可以不用。 参数传递：传引用和传值：形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将被绑定到对应的实参上面，否则，将实参的值拷贝后赋值给形参。 1、使用引用传递避免拷贝，如果无须改变形参的值，最好声明为常量引用2、使用引用形参返回额外信息 const形参和实参顶层const作用于对象本身，和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。所以：1void fcn(const int i) 调用时，因为顶层const被忽略，所以可以传入常量和非常量，同时，因为忽略顶层const的问题：12void fcn(const int i) &#123;&#125;void fcn(int i) &#123;&#125; 虽然C++支持函数重载，但是由于忽略了顶层const的关系，这样属于重复定义了该函数。 数组形参1、普通数组形参因为数组不允许被拷贝以及使用数组时通常会将其转化为指针。因此当我们向函数传递一个数组时，实际上传递的是指向数组首元素的指针。1234//虽然形式不同，但是这三个print函数是等价的，每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]); //此处的10表示我们期望数组含有多少元素，实际不一定 如果这样定义三个函数，编译器会报错，因为重复定义了。 2、数组引用形参C++允许将变量定义成数组的引用，基于此，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，用法如下:12void print(int (&amp;arr)[10]); //&amp;arr两端的括号必不可少，表示arr是具有10个整数的整型数组的引用void print(int &amp;arr[10]); //错误：将arr声明成了引用的数组 3、传递多维数组和其他数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。又因为并不存在多维数组，多维数组只是数组的数组，所以多维数组的首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分，所以不能忽略：12void print(int (*matrix)[10], int rowSize) &#123;&#125; //(*matrix)两端的括号必不可少void print(int matrix[][10], int rowSize) &#123;&#125; //与上面的定义等价 默认实参1double get_area(int a = 10, int b = 10); 如上面的代码中，每个形参都提供了一个默认实参，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。因为get_area函数为它的所有形参都提供了默认实参，所以我们可以用0、1、2个实参来调用该函数：123area = get_area();area = get_area(1); //等价于get_area(1, 10)area = get_area(11, 11); //等价于get_area(11, 11)； 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)，所以只能省略尾部的实参。 函数的返回值1、没有返回值的函数没有返回值的函数只能存在于返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。 2、有返回值的函数返回类型不是void的函数内的每一条return语句必须返回一个与分会类型相同类型的，或者是能隐式地转换成函数的返回类型的值。 3、值的返回的方式返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。注意：不要返回局部对象的引用或者指针 4、引用返回左值函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。 5、返回数组指针同样，因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用，但是由于返回数组的指针或引用的写法太过复杂，推荐使用尾置返回类型。（之后另开博客介绍） 函数重载1、重载函数的定义如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为函数重载(overload)。这些函数接受的形参类型不一样，但是执行的操作类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。对于重载的函数，它们应该在形参数量或形参类型上有所不同。1、不允许两个函数出了返回类型外其他所有的要素都相同，若如此，则第二个函数的声明是错误的。2、虽然两个形参列表看起来不一样，但其实是一样的，如下：12int lookup(const int&amp; a);int lookup(const int&amp;); //虽然一个形参有名字，一个没有，但其实一样 123typedef Phone Telnoint lookup(const Phone&amp;);int lookup(const Telno&amp;); //Telno和Phone类型相同 12int lookup(int);int lookup(const int); 拥有顶层const的形参无法和另一个没有顶层const的形参区分开来12int lookup(int&amp;);int lookup(const int&amp;); 底层const可以被区分 2、重载函数的调用编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较结果决定调用哪个函数，这个过程叫做函数匹配(function matching)或重载确定(overload resolution)，下面会着重介绍。调用重载函数的三种结果：1、编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码。2、找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息。3、有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用(ambiguous call)。 内联函数将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联地”展开。1234incline const string &amp;shorterString(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt;= s2.size() ? s1: s2;&#125; 该内联函数在调用的时候：1cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; 将在编译过程中展开成类似于下面的形式：1cout &lt;&lt; s1.size() &lt;= s2.size() ? s1: s2 &lt;&lt; endl; 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 函数匹配1、选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。候选函数有两个特征：一是与被调用的函数同名，二是其声明在调用点可见。2、考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数(viable function)。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。3、寻找最佳匹配（如果存在的话），从可行函数中选择与本次调用最匹配的函数。原则是实参类型与形参类型越接近，匹配的越好。含有多个形参的函数匹配情况比较复杂，如果出现： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有一个函数“脱颖而出”，则该调用是二义性调用。 实参类型转换优先级1、精确匹配，包括以下情况： 实参类型和形参类型相同 实参从数组类型或函数类型转换成相应的指针类型 向实参添加顶层const或者从实参中删除顶层const 2、通过const转换实现的匹配3、通过类型提升实现的匹配4、通过算术类型转换或指针转换实现的匹配5、通过类类型转换实现的匹配 函数指针函数指针声明和定义函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。1bool lengthCompare(const string &amp;, const string &amp;); 该函数的类型是bool(const string &amp;, const string &amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：1bool (*pf)(const string &amp;, const string &amp;); //*pf必须要加括号，否则表示名为pf，返回值为bool*的函数 函数指针的使用当我们将函数名作为一个值使用时，该函数自动地转换成指针。12pf = lengthCompare; //pf指向名为lengthCompare的函数pf = &amp;lengthCompare; //等价的赋值语句，取地址符是可选的 此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。在指向不同函数类型的指针间不存在转换规则，必须精确匹配 函数指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上确实当成指针使用：1234void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); //第三个参数会自动转换成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;， const string &amp;));//等价声明","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"随笔_","date":"2017-03-10T15:28:23.000Z","path":"2017/03/10/2017年03月10日23-27-37/","text":"Welcome to my blog, enter password to read. Decrypt U2FsdGVkX1+h1Ni/L7TOKzizy/A0l9Er5QHnuO+gOiN/QsbKc087HTJ3Tmzn7I9CWlVI/u72jNisirbJJkvNLUXhDOVskLl40vb9E0Rk9X2GM2yUy5lo62iv4cQlPQl275M9neFO2lN3GcoqjE2wodX7ocJyo7XoIYmS4K4DiP5QcVFZG+D1PVPc/KEWxzSheDEmxUy4zAwW4pOW+5Fv/MeD4DbrBvYvXValiTRY2SX2Psly0ihq+Sex+t1/Yg4MG/EAEngt6+PGFYpaD4YNZ7CkIKXSuMK4Pwv/dm2KeSU1Euy2LmXDcupjF3y44+AFaVfbSFpsFp/2FzoRBZ5KlTrU/XmsCTlhIT2I7YeJNNFbEpi+/gVQJv76K/Mdh8f+ZnnPhRJKs5tSx/VosPO82UFvOhV6U3ql5VBvyfreoDCuEPU7G/QlrseZz3RQJTcVZhm87nvLpWUOBHSX1yT2YNgOwxDY0X24cFKsEXuG29DiPQPX3HMr4czvXwzcMveTCYqSKRB2s5F5aR9A4iH/DzktrT5vQiQW8/eKAAIq1rf+S6i1ANKMgwqkEgQFHQT+V8lL3HC4QykTRQmZYTkKvr5kgwf6w2R+IFWrfEQoAsYoSqVXeprXA8p5Wx42HbJqzoz+7eOh3lXiNdR6sQ8yTlupMisnPuYkDBKe900GrbJiz8H669scmUoJIVYp2kb/PUwQZEVQzyx9vLRI9NSXjGrkB7fMDmrRywOHjRJKX07K7Eq48pbNIHRRuRtehXRLPkT4/Ou6NoX20YDODB3UzWLza1Cges6O7PlzNtqKI5WytbZMLIo3Int5Vj41D+DPMc5B3123+JfirMm5Xuax3NMT+mP7oSp75VhErsg1gAQGE3Q8d6PI62i41qJO7kvtt4s5WZXTd4yoPAgj9GdnOg1s0Ri4tUUQ2tXTVh/LvKO9cEkjB2qsN6/UKZmYOtxJiu6CIp6Lo17ihrc7b5KdQY6d9WMYmA0JxJHlrDj4U5laFnz/4FefkrhvLNH+oJbt7cZ+1TQcBQIYhyvMYp6SE/JVJixNTcdNGElqLge0PDsxImZea96lO+M0eVngUl+u+Gte3H/WmS5Iq+LnQ7pEXJz4nGSn13/7v0b5da25Cc3yhlZd6q/LQBUwjzqVWL7TOkntbbjYThkQT7HT8ZzOFNJs0ofOnFR7rMf+pObqgviiIZ0yOadMUp5TJZs/6oQhBF4ddFA6lsXe+QmEiim6BKezupOoAFVYvgvJDo9bziS5yPL6j4lQFHvkQM1CRDiu7h9DBvRDvEpN4HUmCSrdvm24GJYkiFK8zwJ/kmel4UTWyEMybJUv+12gR2KhQtp8tnfJrqn62i8zi1NdrCQxiH8EnYkDPcYwBGgOCKYimCcWKJrFZQ8vlmjGyXnkgfP/kqDccbjdBesPhmx4HJlOFMMVIN7uvGL/A7Cd5n8Tnvf4ngZ47UygtswoFYhUvIsEKd95MiDqyzSRRTO/yoXAC+SKaAHc0Ip6khkipYmdkGTlnLM5WRY9g+vf9FEAnhwTTgp6c6xEMAzULyqJEETV6dqSA9lcFiQvdkhN4op/LPdOk4pfanQnIVKpmJsV6eww7nI/83lEuvJKgtxNV2kmpT7veEaW8osnAGCmZn8mVPbGyZ9vnBs/ieaK8ac/5PuBbj6vQGnJlcPgVvm2+tysyaAz5LpBJlnV7JtjCalIodlKF72SeNzSKxY8DuZtd/63JNaE6gyP4kxfQAQH45HN/ARocR515bwoXc8k0EVjKwtwo/TeEsPD14cc4wapfo1mn7WiRjzZFrPYHhlCGQTRnqxn4sXnNZLM7WYD9Qh4WkvNtpvxeONn20ZEkP6ym4mvK7uDjS7jT+gX7CQFHAIbwCrC+Fg+IV+NHasGSaJ+/Ot2KP7VElfo7liem+rpk/Y5JWcbmcIvfuRc/HogON1PLFiF8mNKq9F9NruxqKQfLc4OJixfO+N82UGD6G2kNiacBRIz/uS7DXl5oaqmRP4fgbLXcyf7RpQ2xUMLCmgk2waGKZCasRE/Dc87fHSwejmpxOkzoFq5pcwpQ+YjpBTJPcaibEZu26uYdVI+fO1esyo1JVsgD9rXUc1n4XgjsR8sVSntIY8qROcHhZam4pEyxbpcRhGTNn/lXwfhWYNsSEAGOsChbEiSIx31eitKjuPIjJ4Vmkz5qZ6dndjOuAl/xXjmagkyw8cwVw6pAwqfU/S5SMge0MfJY4FVB/6TUZP5HNCxkVsLbGw6FfVsGs6CCqw0An0kpdkg9wX208J1CReHylmK8dC5meZWTzKMBRo5G4wX6RdPtZjtk56Vi8dld59KV53N9Eyjqhs2cM5gLluKp72kYr7JrdWkGiFoXmreBmMznKo8ojrLdx+YUgSBV+4brAGorkxwhNuypucKNHRMtGy4iX2ywss4sBJ9oUwtiBQUJQ5zRbJhvjWYRlE6PC66miLAmOTxH1lkfGuK8nwR+kRuKq3v91OltdK+R7pB6YJ3fhY7yXAkdBhi0/uU2dbzmw99zemrTU/tsrj+M7ApcdC7N0z5S2wt4wyO1hDgNQTc1ZdWM/vFUn5VZhYWQr2hxLHb3kQ1hHfLZFRavTRINYCU7dd3Y5T3Fy99pBYORHCvVOWOc8FRbZuEJRfMd4N1PvSKcaP3bPejzzexehR+xNULYFASMrDa6M0uU9aAoQ2j3YKUT27Dm7R1+ui6hgljm/4N4SK9p8aZ31PU2tJRVh6XRXZk7JOANUjzhpVLEybnJj3EKjQc5gsLF94ZRpaR2nNSeTOr8Wy68gCTv069Ca0pTOzZ1BopWtgPyxnU7u95bCML/zEzI6lyv2Brsf2sAj7tHhR/dF9XiQyMLKfwZHe+O++9sGngf7/Zf9sccMry4Vy50zmHktQPFQCczK6EuLCi0FvQGWUR8PdmMIw=","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++中const的用法","date":"2017-03-10T04:30:45.000Z","path":"2017/03/10/const/","text":"const变量const又叫做const限定符，用关键字const对变量的类型加以限定，可以使得变量的值不能被改变。 123const int i = 1; //正确：编译时初始化const int i = get_size(); //正确：运行时初始化const int k; //错误：k是一个未经初始化的常量 没有初始化的常量变量编译错误其实很好理解，因为经过const限定之后变量的值已经无法改变，如果没有初始化那么这个变量的值不确定，且之后其值不能被改变。 const引用const引用称为对常量的引用，简称为“常量引用”,顾名思义，就是这个对象是一个引用，而且这个对象经过const限定符作用之后，对象的值不能被改变。12345678int main() &#123; const int c1 = 10; const int &amp;r1 = c1; int c2 = 4; const int &amp;r2 = c2; c2 = 5; cout &lt;&lt; r2 &lt;&lt; endl;&#125; 如上所示，常量引用r1,r2是一个常量，而同时，因为const的限制，r1和r2的值不能改变，所以通过r1和r2修改c1和c2的值也就不可能，但是c2因为没有const的限制，可以通过c2修改自身的值。 引用的类型必须与其引用对象的类型一致，但存在例外。一种则是允许常量引用绑定一个非常量的对象，但是不能通过该常量引用改变绑定对象的值，此种情况上面已经出现，不在赘述。另一种是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。12double dval = 3.14;const int &amp;ri = dval; 上述代码是合法的操作c机制是12const int temp = dval;const int &amp;ri = temp; 也就是先将dval转化为整型，注意，其中的temp是临时量，所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。而如果ri不是常量，即：12double dval = 3.14;int &amp;r1 = dval; 此时编译器会报错，错误如下：12error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’int &amp;r1 = dval; 指针和const与引用一样，也可以令指针指向常量或非常量，类似于常量引用，指向常量的指针（不是常量指针）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：1234const double pi = 3.14;double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个常量*cptr = 42; //错误：不能给*cptr赋值 同样，指针的类型必须与其所指对象的类型一致，但是与引用一样，存在例外，允许一个指向常量的指针指向一个非常量的对象：12double dval = 3.14;const double *cptr = &amp;dval; //不能通过cptr改变dval的值 指针是对象而引用不是，所以允许把指针本身定为常量。常量指针必须初始化，一旦初始化完成，则指针的值不能被修改。1234int errNumb = 0;int *const curErr = &amp;errNumb;const double pi = 3.14;const double *const pip = &amp;pi; 将号放在const关键字之前用以说明指针是一个常量，不变的是指针本身的值而非指向的那个值。从右向左阅读解析，如上面代码第二行中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是，意思是curErr是一个常量指针。最后，声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。同理，我们可以看出pip是一个常量指针，指向的对象是一个双精度浮点型常量。 指向常量的指针和常量指针的对比指向常量的指针是指指针指向的值是一个常量（存在上述的例外），这就说明指针的值是可以被改变的，而常量指针是指指针本身是一个常量，但是指针指向的值不一定是常量。 顶层const指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用；底层const则与指针和引用等复合类型的基本类型部分有关。123456int i = 0;int *const pl = &amp;i; //顶层const int ci = 42; //顶层const int *p2 = &amp;ci; //底层const int *const p3 = p2; //左边是底层，右边是顶层const int &amp;r = ci; //用于声明引用的const都是底层const 常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：1234const int max_files = 20; //是常量表达式const int limit = max_files + 1; //是常量表达式int staff_size = 27; //不是常量表达式，因为只是int类型const int sz = get_size(); //不是，sz的值要到运行时确定","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Hello World","date":"2017-03-10T02:44:44.830Z","path":"2017/03/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"C和C++中声明和定义的区别","date":"2017-03-09T16:07:31.000Z","path":"2017/03/10/test-1/","text":"声明使得名字为程序所知，而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与声明相同，然而定义还申请了存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量123extern int i； //声明i而不是定义iint j; //声明并且定义了j 任何包含了显式初始化的声明即成为定义。 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i = 3;&#125; 123error: ‘i’ has both ‘extern’ and initializerextern int i = 3; ^ 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到变量的文件必须对其进行声明，却绝对不能重复定义。 正确的用法如下： test.hpp12345#include &lt;iostream&gt;using namespace std;int i = 2; test.cpp12345678910111213#include &lt;iostream&gt;#include \"test.hpp\"using namespace std;extern int i;int main() &#123; cout &lt;&lt; i; i = 1; cout &lt;&lt; endl &lt;&lt; i; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]