[{"title":"C++ Function","date":"2017-03-11T07:34:55.000Z","path":"2017/03/11/function/","text":"函数定义：一个典型的函数定义包括以下部分：返回类型(return type)、函数名、由形参(parameter)组成的列表、函数体(function body)。 函数声明：和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。如果一个函数永远不会被用到，允许只有声明，没有定义。函数的声明和函数的定义很类似，唯一的区别是函数声明无需函数体。由于不包含函数体，形参的名字也可以不用。 参数传递：传引用和传值：形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将被绑定到对应的实参上面，否则，将实参的值拷贝后赋值给形参。 1、使用引用传递避免拷贝，如果无须改变形参的值，最好声明为常量引用2、使用引用形参返回额外信息 const形参和实参顶层const作用于对象本身，和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。所以：1void fcn(const int i) 调用时，因为顶层const被忽略，所以可以传入常量和非常量，同时，因为忽略顶层const的问题：12void fcn(const int i) &#123;&#125;void fcn(int i) &#123;&#125; 虽然C++支持函数重载，但是由于忽略了顶层const的关系，这样属于重复定义了该函数。 数组形参1、普通数组形参因为数组不允许被拷贝以及使用数组时通常会将其转化为指针。因此当我们向函数传递一个数组时，实际上传递的是指向数组首元素的指针。1234//虽然形式不同，但是这三个print函数是等价的，每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]); //此处的10表示我们期望数组含有多少元素，实际不一定 如果这样定义三个函数，编译器会报错，因为重复定义了。 2、数组引用形参C++允许将变量定义成数组的引用，基于此，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，用法如下:12void print(int (&amp;arr)[10]); //&amp;arr两端的括号必不可少，表示arr是具有10个整数的整型数组的引用void print(int &amp;arr[10]); //错误：将arr声明成了引用的数组 3、传递多维数组和其他数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。又因为并不存在多维数组，多维数组只是数组的数组，所以多维数组的首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分，所以不能忽略：12void print(int (*matrix)[10], int rowSize) &#123;&#125; //(*matrix)两端的括号必不可少void print(int matrix[][10], int rowSize) &#123;&#125; //与上面的定义等价 默认实参1double get_area(int a = 10, int b = 10); 如上面的代码中，每个形参都提供了一个默认实参，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。因为get_area函数为它的所有形参都提供了默认实参，所以我们可以用0、1、2个实参来调用该函数：123area = get_area();area = get_area(1); //等价于get_area(1, 10)area = get_area(11, 11); //等价于get_area(11, 11)； 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)，所以只能省略尾部的实参。 函数的返回值1、没有返回值的函数没有返回值的函数只能存在于返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。 2、有返回值的函数返回类型不是void的函数内的每一条return语句必须返回一个与分会类型相同类型的，或者是能隐式地转换成函数的返回类型的值。 3、值的返回的方式返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。注意：不要返回局部对象的引用或者指针 4、引用返回左值函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。 5、返回数组指针同样，因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用，但是由于返回数组的指针或引用的写法太过复杂，推荐使用尾置返回类型。（之后另开博客介绍） 函数重载1、重载函数的定义如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为函数重载(overload)。这些函数接受的形参类型不一样，但是执行的操作类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。对于重载的函数，它们应该在形参数量或形参类型上有所不同。1、不允许两个函数出了返回类型外其他所有的要素都相同，若如此，则第二个函数的声明是错误的。2、虽然两个形参列表看起来不一样，但其实是一样的，如下：12int lookup(const int&amp; a);int lookup(const int&amp;); //虽然一个形参有名字，一个没有，但其实一样 123typedef Phone Telnoint lookup(const Phone&amp;);int lookup(const Telno&amp;); //Telno和Phone类型相同 12int lookup(int);int lookup(const int); 拥有顶层const的形参无法和另一个没有顶层const的形参区分开来12int lookup(int&amp;);int lookup(const int&amp;); 底层const可以被区分 2、重载函数的调用编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较结果决定调用哪个函数，这个过程叫做函数匹配(function matching)或重载确定(overload resolution)，下面会着重介绍。调用重载函数的三种结果：1、编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码。2、找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息。3、有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用(ambiguous call)。 内联函数将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联地”展开。1234incline const string &amp;shorterString(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt;= s2.size() ? s1: s2;&#125; 该内联函数在调用的时候：1cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; 将在编译过程中展开成类似于下面的形式：1cout &lt;&lt; s1.size() &lt;= s2.size() ? s1: s2 &lt;&lt; endl; 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 函数匹配1、选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。候选函数有两个特征：一是与被调用的函数同名，二是其声明在调用点可见。2、考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数(viable function)。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。3、寻找最佳匹配（如果存在的话），从可行函数中选择与本次调用最匹配的函数。原则是实参类型与形参类型越接近，匹配的越好。含有多个形参的函数匹配情况比较复杂，如果出现： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有一个函数“脱颖而出”，则该调用是二义性调用。 实参类型转换优先级1、精确匹配，包括以下情况： 实参类型和形参类型相同 实参从数组类型或函数类型转换成相应的指针类型 向实参添加顶层const或者从实参中删除顶层const 2、通过const转换实现的匹配3、通过类型提升实现的匹配4、通过算术类型转换或指针转换实现的匹配5、通过类类型转换实现的匹配 函数指针函数指针声明和定义函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。1bool lengthCompare(const string &amp;, const string &amp;); 该函数的类型是bool(const string &amp;, const string &amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：1bool (*pf)(const string &amp;, const string &amp;); //*pf必须要加括号，否则表示名为pf，返回值为bool*的函数 函数指针的使用当我们将函数名作为一个值使用时，该函数自动地转换成指针。12pf = lengthCompare; //pf指向名为lengthCompare的函数pf = &amp;lengthCompare; //等价的赋值语句，取地址符是可选的 此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。在指向不同函数类型的指针间不存在转换规则，必须精确匹配 函数指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上确实当成指针使用：1234void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); //第三个参数会自动转换成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;， const string &amp;));//等价声明","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"随笔_","date":"2017-03-10T15:28:23.000Z","path":"2017/03/10/2017年03月10日23-27-37/","text":"恰逢周五，家里打电话来，又再催了家里把之前的两辆旧的自行车卖了，暑假的时候打算买辆新的自行车骑行回家，望可成行。 今天看公号文章的时候，看到一段挺有感觉的，摘自昌记负食的《考研失败以后的150天》 为什么我从来不肯说，我成绩差是因为我努力在辩论和社团活动中体验人生，我考研是为了完成自己在学术上的梦想，我找工作是因为我对贵司的热爱呢？ 因为本来就不是这样啊。 我成绩差就是因为懒，考研就是为了逃避就业，找工作就是因为想赚钱，想吃涮羊肉。 与君共勉吧！","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++中const的用法","date":"2017-03-10T04:30:45.000Z","path":"2017/03/10/const/","text":"const变量const又叫做const限定符，用关键字const对变量的类型加以限定，可以使得变量的值不能被改变。 123const int i = 1; //正确：编译时初始化const int i = get_size(); //正确：运行时初始化const int k; //错误：k是一个未经初始化的常量 没有初始化的常量变量编译错误其实很好理解，因为经过const限定之后变量的值已经无法改变，如果没有初始化那么这个变量的值不确定，且之后其值不能被改变。 const引用const引用称为对常量的引用，简称为“常量引用”,顾名思义，就是这个对象是一个引用，而且这个对象经过const限定符作用之后，对象的值不能被改变。12345678int main() &#123; const int c1 = 10; const int &amp;r1 = c1; int c2 = 4; const int &amp;r2 = c2; c2 = 5; cout &lt;&lt; r2 &lt;&lt; endl;&#125; 如上所示，常量引用r1,r2是一个常量，而同时，因为const的限制，r1和r2的值不能改变，所以通过r1和r2修改c1和c2的值也就不可能，但是c2因为没有const的限制，可以通过c2修改自身的值。 引用的类型必须与其引用对象的类型一致，但存在例外。一种则是允许常量引用绑定一个非常量的对象，但是不能通过该常量引用改变绑定对象的值，此种情况上面已经出现，不在赘述。另一种是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。12double dval = 3.14;const int &amp;ri = dval; 上述代码是合法的操作c机制是12const int temp = dval;const int &amp;ri = temp; 也就是先将dval转化为整型，注意，其中的temp是临时量，所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。而如果ri不是常量，即：12double dval = 3.14;int &amp;r1 = dval; 此时编译器会报错，错误如下：12error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’int &amp;r1 = dval; 指针和const与引用一样，也可以令指针指向常量或非常量，类似于常量引用，指向常量的指针（不是常量指针）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：1234const double pi = 3.14;double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个常量*cptr = 42; //错误：不能给*cptr赋值 同样，指针的类型必须与其所指对象的类型一致，但是与引用一样，存在例外，允许一个指向常量的指针指向一个非常量的对象：12double dval = 3.14;const double *cptr = &amp;dval; //不能通过cptr改变dval的值 指针是对象而引用不是，所以允许把指针本身定为常量。常量指针必须初始化，一旦初始化完成，则指针的值不能被修改。1234int errNumb = 0;int *const curErr = &amp;errNumb;const double pi = 3.14;const double *const pip = &amp;pi; 将号放在const关键字之前用以说明指针是一个常量，不变的是指针本身的值而非指向的那个值。从右向左阅读解析，如上面代码第二行中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是，意思是curErr是一个常量指针。最后，声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。同理，我们可以看出pip是一个常量指针，指向的对象是一个双精度浮点型常量。 指向常量的指针和常量指针的对比指向常量的指针是指指针指向的值是一个常量（存在上述的例外），这就说明指针的值是可以被改变的，而常量指针是指指针本身是一个常量，但是指针指向的值不一定是常量。 顶层const指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用；底层const则与指针和引用等复合类型的基本类型部分有关。123456int i = 0;int *const pl = &amp;i; //顶层const int ci = 42; //顶层const int *p2 = &amp;ci; //底层const int *const p3 = p2; //左边是底层，右边是顶层const int &amp;r = ci; //用于声明引用的const都是底层const 常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：1234const int max_files = 20; //是常量表达式const int limit = max_files + 1; //是常量表达式int staff_size = 27; //不是常量表达式，因为只是int类型const int sz = get_size(); //不是，sz的值要到运行时确定","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"Hello World","date":"2017-03-10T02:44:44.830Z","path":"2017/03/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"C和C++中声明和定义的区别","date":"2017-03-09T16:07:31.000Z","path":"2017/03/10/test-1/","text":"声明使得名字为程序所知，而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与声明相同，然而定义还申请了存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量123extern int i； //声明i而不是定义iint j; //声明并且定义了j 任何包含了显式初始化的声明即成为定义。 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i = 3;&#125; 123error: ‘i’ has both ‘extern’ and initializerextern int i = 3; ^ 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到变量的文件必须对其进行声明，却绝对不能重复定义。 正确的用法如下： test.hpp12345#include &lt;iostream&gt;using namespace std;int i = 2; test.cpp12345678910111213#include &lt;iostream&gt;#include \"test.hpp\"using namespace std;extern int i;int main() &#123; cout &lt;&lt; i; i = 1; cout &lt;&lt; endl &lt;&lt; i; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]