[{"title":"","date":"2017-04-06T16:34:22.000Z","path":"2017/04/07/2017-04-07-00-34-15/","text":"Welcome to my blog, enter password to read. Decrypt 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","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"2017年4月6日23:47:01","date":"2017-04-06T15:47:09.000Z","path":"2017/04/06/2017年4月6日23-47-01/","text":"Welcome to my blog, enter password to read. Decrypt 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","tags":[{"name":"随写","slug":"随写","permalink":"http://yoursite.com/tags/随写/"}]},{"title":"拷贝、赋值、析构","date":"2017-04-06T12:36:00.000Z","path":"2017/04/06/拷贝/","text":"拷贝构造函数定义如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数的第一个参数必须是一个引用类型，且几乎总是一个const的引用。 如果类没有显式地定义一个拷贝构造函数，那么编译器会为其合成一个拷贝构造函数 合成拷贝构造函数合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。 成员的类型决定了如何拷贝：对于类类型的成员，会使用拷贝构造函数来拷贝；内置类型的成员则直接拷贝；数组类型则会逐元素地拷贝。 拷贝初始化(拷贝构造函数使用的时候)： 用 = 号定义变量 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 拷贝构造函数被用来初始化非引用类类型参数，如果拷贝构造函数的参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环 拷贝赋值运算符定义赋值运算符是一个名为operator= 的函数。类似于其他函数，运算符函数也有一个返回类型和一个参数列表。重载赋值运算符，必须定义为成员函数，如此才可以将this参数隐式地绑定到左侧运算对象上，而右侧运算对象作为显式参数传递。拷贝赋值运算符接受一个与其所在类相同类型的参数。且为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。如果类没有定义赋值运算符重载函数，那么编译器会为其合成一个。 合成赋值运算符与拷贝构造函数类似，会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，通过成员类型的拷贝赋值运算符来完成的。同样，对于数组，逐个赋值数组元素。 编写赋值运算符需注意 如果将一个对象赋予它自身，赋值运算符必须能正确工作 大多数赋值运算符组合了析构函数和拷贝构造函数的工作(先析构左侧运算对象，再将右侧运算对象拷贝给左侧运算对象) 析构函数定义及作用析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员。 析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数，因此，不能被重载，一个给定的类只有一个析构函数。 在一个析构函数中，首先执行函数体，然后销毁成员，析构函数函数体并不销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。成员按照初始化顺序的逆序销毁。 通常，析构函数释放对象在生存期分配的所有资源。成员销毁时发生什么完全以来于成员的类型。类类型的成员需要执行成员自己的析构函数，内置类型则不需要进行任何操作。 隐式销毁一个内置指针类型的成员不会delete它所指向的对象，智能指针属于类类型，所以具有析构函数，在在析构阶段会被自动销毁，同时释放指向的内容 调用时间无论何时一个对象被销毁，就会自动调用其析构函数 变量在离开其作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器被销毁时，其元素被销毁 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁 对于临时对象，当创建它的完整表达式结束时被销毁","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"类的构造函数","date":"2017-04-04T02:30:30.000Z","path":"2017/04/04/类的构造函数/","text":"什么是构造函数(constructor)每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数老控制其对象的初始化过程，这些函数叫做构造函数。 构造函数的特点 构造函数的名字和类的名字相同 构造函数没有返回值 一个类可以包括多个构造函数，不同的构造函数之间必须在参数数量或参数类型上有所区别 构造函数不能被声明为const的 对于创建一个const对象，直到构造函数完成初始化的过程，对象才真正取得其常量属性。 类的常量数据成员的在构造函数中初始化使用初始值列表初始化(在函数体中是对常量成员的赋值，不是初始化，因此会导致错误)的方法 同理，引用类的数据成员也必须初始化，规则同上。 使用初始化列表初始化成员时，初始化的顺序与它们在类定义中的出现顺序一致，构造函数初始值列表中初始值的顺序的前后位置关系不会影响实际的初始化顺序。数据成员的初始化在函数体开始前就已完成 建议使用构造函数初始值：在很多类中，初始化和赋值的区别事关底层效率的问题：前者直接初始化数据成员，后者先初始化再赋值；再者，一些数据成员必须被初始化，如const、引用、未提供默认构造函数的类 默认构造函数定义如果我们的类没有显示地定义任何构造函数，那么编译器会为我们隐式地定义一个默认构造函数。 编译器创建地默认构造函数又称为合成地默认构造函数。初始化规则如下： 如果存在类内地初始值，用其来初始化成员：C++11规定，可以为数据成员提供一个类内初始值，创建对象时可以用于初始化数据成员。类内初始化就是在定义成员变量的同时将其初始化。 否则，默认初始化该成员：内置类型的变量未被显式初始化，值由定义的位置决定，定义于任何函数体之外的变量被初始化为0；定义于函数体内部的内置类型变量(局部变量，包括类中的成员变量)将不被初始化。 =default的含义在C++11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 =default 来要求编译器生成构造函数。=default 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default出现在类的内部，则默认构造函数是内联的。如果在类的外部，则默认情况下不是内联的。 默认初始化发生的时间当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生： 当我们在块作用域内不适用任何初始值定义一个非静态变量或者数组时 当一个类本身含有类类型的成员且使用合成的默认构造函数时 当类类型的成员没有在构造函数初始值列表中显式地初始化时 值初始化在以下情况发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时 当我们不使用初始值定义一个局部静态变量时 当我们通过书写形如 T() 的表达式显式地请求值初始化时 委托构造函数(delegating constructor)一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。 一个委托构造函数有一个成员初始值的列表和一个函数体。在委托构造函数中，成员初始值列表只有一个唯一的入口，就是类名本身。与其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 12Sales_data(int size, string s) &#123;&#125;Sales_data() : Sales_data(0, \"\") &#123;&#125; //此处就是委托构造函数 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Process Synchronization(进程同步)","date":"2017-04-04T02:15:58.000Z","path":"2017/04/04/Process Synchronization(进程同步)/","text":"Background 对共享数据的并发请求会导致数据的不一致 维持数据的一致需要一个能确保共享同一逻辑地址的协作进程可以有序地执行 The Critical-Section Problem(临界区问题)何为临界区每个进程有一个代码段称为临界区，在该区中进程可能改变共同变量、更新一个表、写一个文件等。这种系统的重要特征是当一个进程进入临界区，没有其他进程可被允许在临界区内执行，即没有两个进程可同时在临界区内执行。 何为临界区问题临界区问题是设计一个以便进程协作的协议。每个进程必须请求允许进入临界区，实现这一请求的代码段称为进入去(entry section)，临界区之后可有退出区(exit section)，其他代码为剩余区(remainder section)。 如何解决临界区问题 强制实施互斥：在具有关于相同资源或共享对象的临界区的所有过程中，一次只允许一个进程进入临界区； 一个在非临界区的进程必须不干涉其他进程； 不允许一个需要访问临界区的进程被无限延迟； 没有进程在临界区时，任何需要进入临界区的进程必须能够立即进入 相关进程的速度和处理器数目没有任何要求和限制 一个进程阻留在临界区中的时间必须时有限的 有空让进；无空等待；择一而入；算法可行 Peterson‘s Solution 经典的基于软件的临界区问题的解答。 适用于两个进程在临界区与剩余区之间交替执行。 LOAD 和 STORE 指令是原子型(atomic)的指令，即该指令不能被中断。 Synchronization Hardware(硬件同步)对于单处理器的环境，临界区问题可简单地解决：在修改共享变量时，禁止中断出现。这样，就能确保当前指令序列地执行不会被中断。由于其他指令不可能执行，所以共享变量也就不会被意外修改。 然而，在多处理器地环境下，这种方法因为效率地原因行不通，因此现代计算机系统提供了特殊硬件指令以允许能原子地(不可中断地)检查和修改字的内容或交换两个字的内容。可以使用这些特殊指令来相对简单地解决临界区问题。 指令TestAndSet()地特点是该指令能原子地执行。因此，如果两个指令TestAndSet()同时执行在不同的CPU上，那么它们会按照任意顺序来执行。这样可以实现互斥。 因为在while的判断语句中的TestAndSetLock(&amp;lock)是原子型的指令因此其在执行时不会被中断，也就是在这个指令执行之后，能够获得期待获得的结果，而不会因为该指令在执行的过程中被中断而导致lock的值被改变，从而导致未知的结果 例如：有两个指令TestAndSet()同时执行在不同的CPU上时，那么它们会按照任意顺序来顺序执行。而不会将TestAndSet()指令拆分为更小的指令交替执行。 缺点 对不能进入临界区的进程，采用忙等待，浪费CPU时间。 将测试能否进入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重了用户编程负担。 Semaphores(信号量)什么是信号量信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。这些操作被称为P和V操作。 在wait()和signal()操作中，对信号量整型值的修改必须不可分地执行，即当一个进程修改信号量值时，不能有其他进程同时修改同一信号量的值。 为了克服忙等待，可以修改信号量wait()和signal()的定义。当一个进程执行wait()操作时，发现信号量不为正，则它必须等待。这里的等待是阻塞(block)自己。即将一个进程放入到与信号量相关的等待队列中，并将该进程的状态切换为等待状态。然后将控制转到CPU调度程序，以选择另一个进程来执行。(相对于忙等待，这种方法需要消耗部分时间在上下文切换) 一个被阻塞在等待信号量S上的进程，可以在其他进程执行了signal()操作之后被重新执行(通过wakeup()操作来实现)，该操作将进程从等待状态切换到就绪状态然后放入就绪队列。 1234typedef struct &#123; int value; struct process *list;&#125;semaphore; wait()操作的实现： 1234567wait(semaphore *S) &#123; S-&gt;value--; if (S-&gt;value &lt; 0) &#123; add this process to S-&gt;list; block(); &#125;&#125; signal()操作的实现： 1234567signal(semaphore *S) &#123; S-&gt;value++; if (S-&gt;value &lt;= 0) &#123; remove a process P from S-&gt;list; wakeup(P); &#125;&#125; 如果信号量的值为负，那么其绝对值就是等待该信号量的进程的个数。 信号量的关键之处是它们原子地执行。必须确保没有两个进程同时对同一信号量执行操作wait()和signal()。 上述地情况也属于临界区问题，wait和signal方法的原子实现，单处理器环境只需要通过在执行wait()和signal()操作时禁止中断来解决。但是在多处理器环境下，则必须提供其他加锁技术(如自旋锁)，以确保wait()和signal()可原子地执行。 必须承认对于这里的wait()和signal()操作的定义，并没有完全取消忙等待，而是取消了应用程序进入临界区的忙等。而且，将忙等限制在操作wait()和signal()的临界区内，这些区比较短。因此，临界区几乎不被占用，忙等很少发生，且所需时间很短。 Deadlock and Starvation(死锁和饥饿)什么是死锁具有等待队列的信号量的实现可能导致这样的情况：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态，这些进程就称为死锁。 什么是饥饿饥饿也叫做无限期阻塞(indefinite blocking)，即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，那么可能会发生无限期阻塞 Classic Problems of Synchronization Bounded-Buffer Problem(有限缓冲问题) 三个信号量，分别初始化：full = 0, empty = 0, mutex = 1 其中mutex的作用是记录对访问这个仓库的进程的数量。 Readers and Writers Problem(读者写者问题) 有两组并发进程：读者和写者，共享一个文件F，要求： 任意多个读者可以同时读取文件； 一次只有一个进程可以往文件中写； 写进程执行写操作前，禁止任何文件读取文件 读-读允许，读-写互斥，写-写互斥 如果读者到： 无读者、写者，新读者可以读 有写者等，但有其他读者正在读，则新读者也可以读 有写者写，新读者等 如果写者到： 无读者，新写者可以写 有读者，新写者等待 有其他写者，新写者等待 如果读者优先，可能导致写进程长时间等待，出现写进程被饿死；实际的系统是写者优先，即当有进程在读文件时，如果有新进程请求写，那么新的读进程被拒绝。 信号量mutex和wrt初始化为1；readcount初始化为0.信号量wrt供写者作为互斥信号量；信号量mutex用于确保在更新变量readcount时的互斥。变量readcount用来跟踪有多少进程正在读对象。 Dining-Philosophers Problem(哲学家吃饭问题)","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"类的this指针","date":"2017-04-01T14:36:51.264Z","path":"2017/04/01/类的this指针/","text":"定义成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。this形参是隐式定义的。任何自定义名为this的参数或变量的行为都是非法的。因为this总是指向“这个”对象，因此this是一个常量指针，且是一个指向非常量类类型的常量指针 类的const成员函数与this指针类的const成员函数是在紧随参数列表之后加上const关键字，这里，const的作用是修改隐式this指针的类型。默认情况下this是一个常量指针，且是一个指向非常量类类型的常量指针，因此，this指针不能被绑定到一个常量对象上。也就使我们不能在一个常量对象上调用普通的成员函数。一旦将成员函数声明为常量成员函数，那么this是指向常量的常量指针，所以常量成员函数不能改变调用它的对象的内容。 赋值运算符重载返回*this一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，因此为了保持一致，这些定义的函数也必须返回引用类型。 从const成员函数返回*this一个常量成员函数的this指针是一个指向const的指针而*this是const对象。因此，常量成员函数的返回类型应该是const&amp;。即使引用返回的是左值，但是由于const的作用也无法改变返回值的值。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello World","date":"2017-04-01T14:36:51.248Z","path":"2017/04/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"","date":"2017-03-31T14:18:29.448Z","path":"2017/03/31/Linux学习/","text":"开机流程与主引导分区(MBR)BIOS是在开机的时候计算机系统会主动执行的第一个程序 BIOS：一个写入到主板上的一个韧体(韧体就是写入到硬件上的一个软件程序) CMOS：记录各项硬件参数且嵌入在主板上的存储器 开机流程如下： 主动执行BIOS，识别第一个可开机的设备(如光盘、硬盘、U盘等) —&gt; MBR，第一个可开机设备的第一个扇区内的 主引导分区块，内包含引导加载程序 —&gt; 引导加载程序(Boot loader)，一支可读取内核文件来执行的软件。—&gt; 内核文件，开始操作系统的功能 Boot loader是操作系统安装在MBR上的一套软件，主要包括 提供菜单：用户可以选择不同的开机选项，是多重引导的重要功能 载入内核文件：直接指向可开机的程序区段来开始操作系统 转交其他loader：将引导加载功能转交给其他loader负责(因为引导加载程序除了可以安装在MBR之外，还可以安装在每个分区的引导扇区(boot sector)) 多重引导的工作： 每个分区都拥有自己的启动扇区 实际可开机的内核文件是放置到各分区内的 loader只会识别自己的系统分区内的可开机内核文件，以及其他的loader而已 loader可直接指向或者是间接将管理权转交给另一个管理程序 Linux安装模式下，磁盘分区的选择目录树结构所谓目录树结构就是以根目录为主，然后向下呈现分支状的目录结构的一种文件结构。 文件系统与目录树的关系(挂载)所谓的挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下；也就是说，进入该目录就可以读取该分区的意思。这个操作称为挂载，进入点的目录称为“挂载点”。由于整个Linux系统最重要的就是根目录，因此根目录一定需要挂载到某个分区。至于其他的目录则可依用户自己的需求来给予挂载到不同的分区。","tags":[]},{"title":"CPU Scheduling","date":"2017-03-22T01:05:51.000Z","path":"2017/03/22/CPU-Scheduling/","text":"Basic ConceptsMaximum CPU utilization obtained with multiprogramming:对于单处理器系统，每次只允许一个进程运行；任何其他进程必须等待，直到CPU空闲能被调度位置。多道程序的目标是在任何时候都有某些进程在运行（通过利用等待某些I/O请求的时间），使CPU使用率最大化。 CPU-I/O区间周期：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。进程执行从CPU区间（CPU burst)开始，在这之后是I/O区间（I/O burst），接着是另一个CPU区间，然后是另一个I/O区间，如此进行下去。最终，最后的CPU区间通过系统请求终止执行。 CPU区间时间曲线： CPU Scheduler（CPU 调度器）从在等待执行的进程中选出一个，并且分配其CPUCPU调度决策发生的时间： 进程从运行到等待的切换 进程从运行到就绪的切换 进程从等待到就绪的切换 进程终止 即CPU中即将没有进程执行的时候 对于第一种和第四种情况，没有选择只有调度。一个新进程(如果存在)必须被执行，此时是从就绪队列中调度出来执行。不过，对于第二种和第三种情况，可以进行选择。 所谓的选择就是选择一个新进程来执行。 当调度只能发生在第一和第四种情况下时，称调度方案是非抢占的(nonpreemptive)的或协作的(cooperative)；否则，称调度方案是抢占的(preemptive)。 非抢占式调度，一旦CPU分配给一个进程，那么该进程会一致使用CPU直到进程终止或切换到等待状态。___### Dispatch(分派器)分派器将CPU的控制权交给短期调度程序选中的进程;包括： 上下文切换 用户模式切换* 跳转到用户程序的适当的位置重启程序先在内核模式进行上下文切换 -&gt; 切换到用户模式 -&gt; 到合适的位置重启程序 分派器停止一个进程而启动另一个所要花的时间称为分派延迟(dispatch latency) Scheduling Criteria(调度准则) CPU utilization - keep the CPU as busy as possible Throughput(吞吐量) - of processes that complete their execution per time unit. Turnaround time(轮转时间) - Turnaround time is the sum of the periods spent waiting to get into memory, waiting in the ready queue, executing on the CPU, and doing I/O. Waiting time - amount of time a process has been waiting in the queue. Response time - amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment). Scheduling Algorithms(调度算法) First-Come,First-Served(FCFS)Scheduling:先请求CPU的进程先分配到CPU。可以使用FIFO队列来实现。不过进程等待时间通常较长。 Shortest-Job-First(SJF)Scheduling:将每个进程与其下一个CPU区间段相关联。当CPU空闲时，会将CPU分配给具有最短CPU区间的进程。SJF是理想的情况，因为无法测定每个进程运行所需的CPU时间，但可以作为上限。 Shortest-Remaining-Time-First(SRTF):抢占式的，将CPU分配给当前执行剩余时间最少的进程。 Determining Length of Next CPU Burst:认为下一个CPU区间的长度与之前的相似，通过计算下一个CPU区间长度的近似值，能选择具有最短预测CPU区间的进程来运行。通常可预测为以前CPU区间的测量长度的指数平均。 Priority Scheduling:每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS顺序调度。优先级算法的一个主要问题是无穷阻塞(indefinite blocking)或饥饿(starvation)。解决方法之一是老化(aging)，即逐渐增加在系统中等待很长时间的进程的优先级。 Round Robin(RR):定义一个较小时间单元(时间片),当时间片走完之后，进程会被抢占同时被加入到就绪队列的末端。如果时间片很大，RR与FCFS类似，如果时间片很小，那么大部分时间浪费在上下文切换。根据经验，80%的CPU区间应该小于时间片，即大部分的进程在一个时间片内可以完成。通常，RR的平均轮转时间高于SJF，但响应时间低于SJF。 Multilevel Queue:将就绪队列分成多个独立队列。根据进程的属性，如内存大小、进程优先级、进程类型，一个进程被永久地分配到一个队列。每个队列有自己的调度算法。进程进入系统后永久地被分配到一个队列。优点是低调度开销，缺点是不够灵活。 Multilevel Feedback Queue:允许进程在队列之间移动。根据不同CPU区间的特点区分进程。如果进程使用过多CPU时间，就被转移到更低优先级队列。在较低优先级队列等待时间过长的进程会被转移到更高优先级队列。这种老化可以阻止饥饿发生。 Multiple-Processor Scheduling(多处理器调度)(非重点) Real-TIme Scheduling Hard real-time systems：要求在一定时间内完成某个任务。 Soft real-time computing: 统计意义上的实时，例如，有的应用要求系统在95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求100%。 Thread Scheduling Local Scheduling:线程库如何决定哪一个线程分配到哪一个LWP Global Scheduling:内核如何决定哪一个内核线程下一个运行","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"2017年03月17日00:17:41","date":"2017-03-16T16:17:44.000Z","path":"2017/03/17/2017年03月17日00-17-41/","text":"Welcome to my blog, enter password to read. Decrypt U2FsdGVkX1+thqF5x0iejhsQwuHqdhxBc+jevc/tun6H+fZ+zoCplng3EuVriKs7kW6OzqgdwpZCLX1mElAOtutOCQfGWFo7mOzogDmai3rFqEEsescTW0kSYXj8d/+XNUmZHuT98suqxQJwHx5HvxMV83kQep/QUqrz/Qg0zHNBM2swB5lJj4Z0my4ThKP/hISkXLIfaA6qEmVp4RB96gg5f5/MVTqE8pq1TpWTSElOSsANHL1PvpN3gqNwfKhytgzZfAVmEW4bAlMIaaG+kGfIaAQGvKFxlmI1hlXAJVik1kuJld2qTJvyBdZNyOEgb1N6yUJSSXJe/bINQwb2YmT6DydbA+o+u0e4lUcMwnYas6sJ1s1zH5hQRXh+KP6INd8x4fpLs9JHrFQSXwGL2n9ZE86q0OztIsWGC5cSHZ8XnmJ4wtI6/qfp2dU+dTbTM5ESIbA595vxv+ot3JUXeOPqlF2FkEDPfRoGD9/o1i1pWQciKgNmKZBiaCnYKAGyywaT9IlCJU8zmh/N9ZAsHpO7ixmYfmzkcSrEEjsN14V1rmVN8XNE23ZrAMbL3UvpB5EfP8k+buGXORIQje0rdnqHqj8a+UmhVaZRKxwWJzzj6Md3QQa+LVdkWDWC1E1yN8PsZ0u2YtNMOMag45nQ9llWXTkONwtdPRgo/9twZeMBN/vhTm0m/3auZvCXsCdRmm+7aS8tFlGr4Rvmf8z5hWUjqS2XxHa6JPzugERdgyxqnm8pF7E6KaokBZsYYLeiaquDBatEcj/iGEGrPfF1yJ0x/PER9xiykC3hMBLNP3oL6QqAkNxdqvmd3NyCTfXKfsPxiIlWY9gZnEFSWDqLlPY2sg8smD4r6v5PJg8m5LZTdTrTSxYaMzYN7enP6zBJTUUD2io/im8I8+WsspbMCrqoHADd2MpNphwZBpqXlC+6hrfaFXWqdHG2nfXKuFTqYK3Yze2l5Nj87nQohjNkEn14db7FBE37Pk9FMg21lFkhsVhNCUrN7FVPsA7BwCIu2g2AWiQc4W+4Lz9be0apx/hXJlClUenALJVc5IFTpW8NrOSED/IwedhOavwuw267pncAkJz1Zi6nMWsKSu/eJvWif+hRP9H5oCaHTJTUgGXVTG/9+wne5JDTlx83paq9wZ+P1xXsypgOqd05QXAsjZUt8bi+OuHAGkX1tWjyS9deB2UuIXejVXZYE7WIRXfVRaw7BjnK1ndHlyZX9ksAGINLvtDviS94UnA9WvN75dGj4JbrIlHHwoPJ3GieCazNCbRgPOMTpUj853pEmdF0oYqLu2cZDghYyxzaHiQoS2HYcOZpYQPL+rkODq9LrOPFgesdlii1pHGzuGF9AStmkn0jWpXmUE/yd4ZIr0PQs5yXdBNYCaUuyi8m4BVfSHHumqPPy9/HpzPM44tKh6my7+pJXkGa1FXlLlTCZELjwnTkktHs+1T0UeBpMJwU4oGfOm2HcYMjm1Jh9J4nBij1r2GVMp+Gih9qb3Jk9pUJeXGnWRM+UqlPQBlTf3RXKwl48OGQrZ/+43xORPK4E08nimY9wYOddVKXs9tQz50szbYnr1lJk0xtmUnelunaZKCVEGOjrjyYicA3DJQnzZM/sw==","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"thread","date":"2017-03-15T15:09:33.000Z","path":"2017/03/15/thread/","text":"Concept:线程是CPU使用的基本单元，由线程ID、程序计数器、寄存器集合和栈组成。线程共享代码段、数据段、和其他操作系统资源 Process: Ownership of memory, files, other resources Thread: Unit of execution we use to dispatch Benefits: Resonsiveness(响应度高) Resource Sharing(资源共享) Economy(经济) Utilization of MP Architectures(多处理器体系结构的利用) Multithreading Models(多线程模型)User and Kernel Threads User Threads: Thread management done by user-level threads library Kernel threads: Threads directly supported by the kernel Many-to-One(多对一模型)多对一模型将许多用户级线程映射到一个内核线程，线程管理是由线程库在用户空间进行的，因此效率比较高。但是如果一个线程执行阻塞了系统调用，那么整个进程会阻塞。而且，任何时候只有一个线程能够访问内核，多个线程不能并行运行在多处理器上。 One-to-One(一对一模型)一对一模型将每个用户线程映射到一个内核线程。当一个线程执行阻塞系统调用时，能允许另一个线程继续执行，也能够并行运行在多处理器系统上。但是每创建一个用户线程就需要创建一个相应的内盒线程，开销大，也就限制了线程数量。 Many-to-Many(多对多模型)多对多模型允许将多个用户线程映射到多个内核线程，同时能够创建足够多的内核线程。 Two-level Model(二级模型) Thread Pools(线程池)线程池的主要思想是在进程开始时创建一定数量的线程，并放到池中等待工作。当服务器收到请求时，它会唤醒池中的一个线程(如果有可用的线程)，并将要处理的请求传递给它。一旦线程完成了服务，它会返回到池中等待工作。如果池中没有可用的线程，那么服务器会已知等待直到有空线程为止。线程池具有如下有点： 通常用现有线程处理请求要比等待创建新的线程要快 线程池限制了在任何时候可用线程的数量。这对那些不能支持大量并发线程的系统非常重要 Thread Specific Data(线程特定数据)一个进程的线程共享进程数据，但是，某些情况下每个线程可能需要拥有自己一些数据的副本，这种数据称为线程特定数据，在我们区别一个进程中的某个线程时尤其有效","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"GDB调试","date":"2017-03-15T05:13:25.000Z","path":"2017/03/15/GDB调试/","text":"文中代码部分及部分讲解转载自陈皓gdb教程相关博客 What is GDB? GDB, the GNU Project debugger, allows you to see what is going on `inside’ another program while it executes – or what another program was doing at the moment it crashed.GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act:Start your program, specifying anything that might affect its behavior.Make your program stop on specified conditions.Examine what has happened, when your program has stopped.Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.The program being debugged can be written in Ada, C, C++, Objective-C, Pascal (and many other languages). Those programs might be executing on the same machine as GDB (native) or on another machine (remote). GDB can run on most popular UNIX and Microsoft Windows variants. 简单来说，GDB就是一个DEBUG的工具 GDB 安装Linux系统下：终端运行如下命令1sudo apt-get install gdb Windows系统下：下载MinGw或者TDM-GCC然后配置一下环境变量就可以在CMD中使用了。安装完成后输入：1gdb -v 出现如下提示表示安装成功：1234567891011121314GNU gdb (Debian 7.11.1-2) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\". 编译说明要使用gdb调试程序，必须在进行编译时（g++或gcc）加入-g选项进行编译：1g++ test.cpp -g 运行GDBlinux系统下编译链接默认生成a.out文件，所以在a.out文件所在目录下执行：1gdb a.out windows系统下默认生成a.exe，同理在a.exe文件所在目录下执行：1gdb a.exe 调试实例及部分简单调试命令test.c:1234567891011121314151617181920#include &lt;stdio.h&gt;int func(int n) &#123; int sum=0,i; for(i=1; i&lt;=n; i++) &#123; sum+=i; &#125; return sum;&#125;int main() &#123; int i; long result = 0; for(i=1; i&lt;=100; i++) &#123; result += i; &#125; printf(\"result[1-100] = %d \\n\", result ); printf(\"result[1-250] = %d \\n\", func(250) );&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960(gdb) b 12 //设置断点，break的缩写，在源程序第12行处。Breakpoint 1 at 0x6e6: file test.c, line 12.(gdb) b func //设置断点，在函数func()入口处。Breakpoint 2 at 0x8048456: file tst.c, line 3.(gdb) info b //查看断点信息Num Type Disp Enb Address What1 breakpoint keep y 0x00000000000006e6 in main at test.c:122 breakpoint keep y 0x00000000000006b7 in func at test.c:4(gdb) r //运行程序，run的缩写Starting program:Breakpoint 1, main () at test.c:1313 long result = 0;(gdb) n //next的缩写，执行下一步14 for(i=1; i&lt;=100; i++) &#123;(gdb) n15 result += i;(gdb) n14 for(i=1; i&lt;=100; i++) &#123;(gdb) n15 result += i;(gdb) c //继续运行程序，continue命令简写。Continuing.result[1-100] = 5050 //程序输出。Breakpoint 2, func (n=250) at tst.c:54 int sum=0,i;(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p i //打印变量i的值，print命令简写。$1 = 134513808(gdb) n6 sum+=i;(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p sum$2 = 1(gdb) n6 sum+=i;(gdb) p i$3 = 2(gdb) n5 for(i=1; i&lt;=n; i++)(gdb) p sum$4 = 3(gdb) bt //查看函数堆栈。#0 func (n=250) at tst.c:5#1 0x080484e4 in main () at tst.c:24#2 0x400409ed in __libc_start_main () from /lib/libc.so.6(gdb) finish //退出函数。Run till exit from #0 func (n=250) at tst.c:50x080484e4 in main () at tst.c:2424 printf(\"result[1-250] = %d /n\", func(250) );Value returned is $6 = 31375(gdb) c //继续运行。Continuing.result[1-250] = 31375 //程序输出。Program exited with code 027. //程序退出，调试结束。(gdb) q //退出gdb。 step（简写为s）命令和next命令都是执行下一步，不同的是step命令会进入函数的内部，而next命令则是会直接执行完函数，然后在该函数的下一步等待如在上面代码的17行加上func(30)并进行gdb调试；1234Breakpoint 1, main () at test.c:1717 func(30);(gdb) n18 printf(\"result[1-100] = %d \\n\", result ); 使用next命令直接跳到18行等待12345678910Breakpoint 1, main () at test.c:1717 func(30);(gdb) sfunc (n=30) at test.c:44 int sum=0,i;(gdb) s5 for(i=1; i&lt;=n; i++) &#123;(gdb) s6 sum+=i;(gdb) s 可以看到，使用s进入到了func函数的内部","tags":[{"name":"调试技术","slug":"调试技术","permalink":"http://yoursite.com/tags/调试技术/"}]},{"title":"指令集","date":"2017-03-13T15:01:26.000Z","path":"2017/03/13/instruction/","text":"Concept: 指令集是CPU可以执行的指令的集合，是计算机设计者和计算机程序员之间的接口，CPU的操作由其可以执行的指令集决定。 Elements of an Instruction Operation code(Opcode) 操作码 表示该指令进行的操作的类型 Source Operand Reference 源操作数 该操作所需输入的操作数 Result Operand Reference 目标操作数 操作产生的需要存储的结果 Next Instruction Reference 下一条指令地址 告诉CPU当前指令完成后下一条指令的地址 Instruction Representation 机器码：指令(无论操作数还是操作码)都是无差别地以二进制的形式存储 汇编语言：操作码用缩写的形式(助记符)表示，说明该指令进行的操作的类型，操作数也以相应的符号来表示 Instruction Types Data processing(数据处理) Data Storage(数据存储) Data movement(I/O) Control(控制) Instruction Set Design Operation repertoire(操作类型储备) How many ops? What can they do? How complex are they? Data types(数据类型) Insturctoin formats(指令格式) Length of opcode field Number of addresses Registers Number of CPU registers availiable Which operations can be performed on which registers? Addressing modes(寻址模式) Types of Operand Addresses Numbers Charcters Logical Data Types of Operation Data Transfer(数据传输) Arithmetic(算术运算) Logical(逻辑运算) Conversion(转换):转换数据的形式，如十进制转为二进制 I/O System Control Transfer of Control(控制转换)：例如跳转，子程序调用 Byte Order(位元组顺序) little-endian(小端规则):LSB(最低有效位，即最左边的位)存储在低位的地址之中。 big-endian(大端规则):LSB存储在高位的地址之中。 0x12345678存储左边为大端规则，右边为小端规则 Addressing Modes(寻址模式)根据对操作数和/或地址的使用不同加以区分的多种寻址方式中的一种说明如何获取指令中操作数和下一条指令,经常不止一种寻址方式被使用，不同的操作码使用不同的寻址方式，指令中的方式字段说明寻址的方式。 Immediate (立即寻址)：操作数是位于指令自身中的常数 Direct (直接寻址)：指令中存储的是操作数的地址 Indirect (间接寻址)：指令中存储的是操作数的地址的地址 Register (寄存器寻址)：操作数是寄存器 Register Indirect (寄存器间接寻址)：对寄存器访问取得操作数地址 Displacement (Indexed) (偏移寻址)：操作数在内存中，其地址是指令中基址寄存器和常数的和 Stack (堆栈寻址)：详情点击 速度排序：立即寻址 &gt; 寄存器寻址 &gt; 直接寻址 &gt; 寄存器间接寻址 &gt; 间接寻址 RISC vs CISCCISC：复杂指令集，有大量的变长的，复杂结构的指令，可以完成复杂的任务RISC：精简指令集，减少了大量非必须指令且简化了剩余的指令使其执行速度加快。特征如下： 所有指令定长（4个字节），通过补0实现使CPU能够快速解码 指令只能从内存加载到寄存器或从寄存器存储到内存 对于算术运算和逻辑运算，没有直接的方法在寄存器和内存之间直接进行（即算术运算指令和逻辑运算指令无法读取内存中的内容） RISC架构拥有大量的寄存器 RISC只有少量的基本的指令 99%的指令可以在一个时钟周期内执行完 由于RISC指令集的精简，其指令用硬件的方法实现 Control Unit(控制单元)Micro-Operations","tags":[{"name":"计算机组成","slug":"计算机组成","permalink":"http://yoursite.com/tags/计算机组成/"}]},{"title":"进程","date":"2017-03-12T14:10:43.000Z","path":"2017/03/12/进程/","text":"Process Concept简单来说，进程就是指正在执行的程序，执行并不一定是在运行。一个进程包括以下三个方面 程序计数器 (program counter) 堆栈段 (stack) 数据段 (data section) 程序包括代码段、当前活动（通过PC的值和处理器寄存器的内容来表示）、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）和数据段（包括全局变量），可能还包括堆(heap)，进程在运行期间动态分配的内存。 如下图所示： Process State new(创建): The proces is being created running(运行): Instructions are being executed waiting(等待): The process is waiting for some event to occur ready(就绪): The process is waiting to be assigned to a processor terminated(终止): The process has finished execution 进程五状态表： Process Control Block(PCB)每个进程在操作系统内用进程控制块来表示，它包含许多与一个特定进程相关的信息。 Process state: 包括创建、就绪、运行、等待、停止等 Program counter: 表示进程要执行的下个指令的地址 CPU registers CPU scheduling information Memory-management information Accounting information I/O status information Process Scheduling为了最大效率地利用CPU，进程调度选择一个可用的进程到CPU上执行。 Process Scheduling Queues(调度队列) Job queue – set of all processes in the system Ready queue – set of all processes residing in main memory, ready and waiting to execute Device queues – set of processes waiting for an I/O device Processes migrate(迁移) among the various queues Scheduler(调度程序)进程在其生命周期中会在各种调度队列之间迁移。为了调度，操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的调度程序来执行的。 长期调度程序(long-term scheduler)：又叫做作业调度程序(job scheduler)从存放”进程”的大容量存储设备的缓存池中选择进程，并加载进内存准备执行。 短期调度程序(short-term scheduler)：又叫做CPU调度程序，从准备执行的进程中选择进程，并为之分配CPU。 中期调度程序(medium-term scheduler)：核心思想是能将进程从内存中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。这种方案称为交换(swapping) 长期调度程序被调用的频率比较低，短期调度程序被调用的频率比较高 Context Switch(上下文切换)将CPU切换到另一个进程需要保存当前进程的状态（保存在PCB中）并恢复另一个进程的状态，这一任务称为上下文切换 Operations on Processes(进程操作)进程创建(Process Creation)进程在其执行过程中，能通过创建进程系统调用创建多个新进程。创建进程称为父进程，而新进程称为子进程。每个新进程可以在创建其他进程，从而行程了进程树。 创建进程的两种可能： 1、父进程与子进程并发(concurrently)执行2、父进程等待，直到某个或全部子进程执行完 新进程的地址空间的两种可能： 1、子进程是父进程的复制品（具有和父进程相同的程序和数据）2、子进程装入另一个新程序 资源共享： 1、父进程和子进程共享所有资源2、父进程分配一部分资源给子进程3、父进程和子进程没有共享资源 进程终止(Process Termination)当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止。这是，进程可以返回状态值到父进程。所有进程资源被操作系统释放。父进程终止子进程的原因： 1、子进程使用了超过它被分配的一些资源2、分配给子进程的任务已不再需要3、父进程退出，如果父进程退出，操作系统不允许子进程继续，这称为级联终止(cascading termination) Cooperating Processes(协作进程)生产者-消费者问题是协作进程的通用范例。生产者进程产生信息以供消费者进程消费。 为了允许生产者进程和消费者进程能并发执行，必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内，当消费者使用一项时，生产者能产生另一项。生产者和消费者必须同步，以免消费者消费一个没有生产出来的项。 缓冲主要存在两种： 1、无限缓冲(unbounded-buffer)：对缓冲大小没有限制。消费者可能不得不等待新的项，但生产者总是可以产生新项2、有限缓冲(bounded-buffer)：缓冲固定，若缓冲为空，消费者必须等待；若缓冲为满，生产者必须等待 Interprocess Communication(进程间通信IPC)通信模型： 共享内存系统通过生产者-消费者问题，协作进程加以实现 消息传递系统消息传递是由操作系统提供机制，让协作进程能通过消息传递工具来进行通信。消息传递工具提供至少两种操作：发送和接受。send(),receive()操作方法： 直接或间接通信 同步或异步通信 自动或显式缓冲 直接或间接通信对于直接通信，需要通信的每个进程明确地命名通信的接受者或发送者。 直接通信的通信线路具有如下特点： 在需要通信的每队进程之间自动建立线路。进程只需要知道相互通信的标识符。 一个线路只与两个进程相关。 每队进程之间只有一个线路。 这种方案展示了对称寻址，即发送和接受进程必须命名对方以便通信。另外有非对称寻址，即只要发送者命名接受者，而接受者不需要命名发送者。 间接通信：通过邮箱或端口来发送和接受信息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一的标识符。间接通信的通信线路具有如下属性： 只有在两个进程共享一个邮箱时，才能建立通信线路。 一个线路可以与两个或更多的进程相关联 两个通信进程之间可有多个不同的线路，每个线路对应于一个邮箱 同步和异步通信消息传递可以是阻塞(block)或非阻塞 —— 也称为同步或异步 阻塞send：发送进程阻塞，知道消息被接收或被邮箱所接收 非阻塞send：发送进程发送消息并继续操作 阻塞receive：接受者阻塞，直到有消息可用 非阻塞receive：接受者收到一个有效消息或空消息 自动或显式缓冲不管通信是直接的或是间接的，通信进程所交换的消息都驻留在临时队列中。 零容量：线路中不能有任何消息处于等待，必须阻塞发送，知道接收者接收到信息。 有限容量：队列长度为有限的n，最多只能有n个消息驻留其中，若未满，可以接收新消息，且发送者可继续执行不必等待。若容量已满，必须阻塞发送直到队列中的空间可用为之。 无限容量：队列长度无线，从不阻塞发送者 零容量情况称为没有缓冲的消息系统，其他情况称为自动缓冲。 Communication in Client-Server","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"随笔_","date":"2017-03-11T14:32:03.000Z","path":"2017/03/11/2017年03月11日22-31-58/","text":"Welcome to my blog, enter password to read. Decrypt U2FsdGVkX1/Twoa4LDUYMqgdcqzXuSLsa+WK/ZGNplxoQyvswGqJYor5toF0J7u7bekCRsxyiDDyUwORgJfCtGyIe7zvJqmFpcO73b8LfzEDZzJukqbLPtUY8gGdY0q/BOpXGgIv3ypnYTvOXiXXCncLrFhdor6WDGPX0w7bdDpfvOgCop4stkMNEh3KWzcm0ua4mKoAodpoTyF5O/c40pJ7ymHTOWbtZDbAmiJX1hfsS/FVFwLMAgzoxcI1OZRnfWZ1xlpd+w6LuX4iPP+cg1GOccbZMFe9Hu29wCQrXOQit/ZC8f/vnNZ88lPKC+kx3Buq9t3/sTlDXnEGwHr5/e0v/2DayWdn8B5eUpZVArjqULbsNipEMwZFneQmi6w8ABFdI+Mijah3tAC/+DzInb7gi62EBEaVV7E5YFO9uobJV3p5OqL0CWFqgAvwWgCP2l+/ey2QWy8DkoXK/tDP6ALin09+X+2IOy2f5vaIfv8eOdcou0ZOb8lflhIaq4IrsJLzBlztjfpZ9FfY8NusHe7A3RbqSOvDWAG5zXQ3TFovoCX0UpF+o0TESkczgMJSLQo+4hOVJTPEgPDelBSlDkBza5ca05Jx6Hb3BZRtZE2eCm1UNF8QvQRBPFVzVB3KEs3+rzBz/MG6OaLixz6eFxbyzwhHuIuxFG4WNC9TmkE0AlLCDC/pLIpTB0H+HtbWK6XIoDShissmdCGWo16DdVHEcm7xswj/nFZvMl+X7vneNDNk1mQUg9ViflunLV/H2NrebRbJOMAwnCLuetB5B7aqFB1s8N8kX74XIFk+Q4cLLn0wBPULRVoUeM7bMzdHfQG7pOhaaDRYHQ/47OntOy9BFAr+vTUfneHQKilYBCo7ST3UcFHNROseKQGRIZZ0MDJk0JlAkE8iewi2JIfqmTyVUS2RbvfSUPmSJbpn5x+FvxprhVcSOzCwwUrhMEQaL6+NyMMR74UDjvu1BsQMLJAfWI56TpwHzodkRV4+Z7IJt5lXZozKDAbQ7ddWhRHZvoJwFgfKfz8AraVdjSe9LcVXwc/64tYPH2vGVvxghW8b0eAtsi8VmdOswUsWsFEoi1Rg0nPldyoa2AqYPtkY5Ynhbl4mBrgjqr2HdywRONxp72AIjswvu7rv5ZpUmHnEDhekMRiSMvxdMhKqeqgKpHHjsxTaqF2tXJoKGP03Jz83j2LS1WyfkYqEwA4xBebahWjYHFDYhJBLfSO6BMsio3cfpCpQmfPS1gAtOTOzUl5lGq2kDRY+0w3fKs6EuvjjJwbVXkClF10nxxtIYiP30Zbel2xyMNl+yTNA6UGS2Uh8yV/N3mJNk6zO2nhE2pd30CUjQKAgJWKmx58DFw4oQp+cJe1rzM4f8z+wK4aB+LbIiyrsutn4P6D+YvP+0h2fgaVbSAnMbfA9wzPyq+dY/y5XJpAt16msuv1qMKETq8Y66jTlgy0IZzfyhLj02P3h1PcHHrkmKQ3l7hB8FklBt9VmCDb79kwkkluGPsa77i1HDI9NAJ1F9Tickhy9byXOLe4RB6fwR0FV18QEsRpoa+WxBOPMcmhfUD1Otar4AKNAySpiX2jCnoxjJHFydD3NDhe7WostdEL3FnSfgoSx8M5dXLVlFzmjGSnnSTZFAkOAImWa2S+N6Y11snghrEbF19R4u5ECt75Au+RMFmovD2x93eWyjW0kr0iBi659SxQzYjk1CdQrPg3gxu03phtpXlb7QlJgF3+0O5oIzhaUTaSOWCtwSi4FRueYybzaprk4u6kbyAr9zr9P9GJVL/LeaA9j2r7h++BhGL9UPGRc3luGriUBVM4nXqKrauYU+PgW7Jp3zCo7+JPNuE7ORZokZhlWQU2/ycNx/2RW/x3IXK7zUjEtpPcxrkW69H3SiXaqCHdRNwdT+2UI1GnSARfm","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++ Function","date":"2017-03-11T07:34:55.000Z","path":"2017/03/11/function/","text":"函数定义：一个典型的函数定义包括以下部分：返回类型(return type)、函数名、由形参(parameter)组成的列表、函数体(function body)。 函数声明：和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。如果一个函数永远不会被用到，允许只有声明，没有定义。函数的声明和函数的定义很类似，唯一的区别是函数声明无需函数体。由于不包含函数体，形参的名字也可以不用。 参数传递：传引用和传值：形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将被绑定到对应的实参上面，否则，将实参的值拷贝后赋值给形参。 1、使用引用传递避免拷贝，如果无须改变形参的值，最好声明为常量引用2、使用引用形参返回额外信息 const形参和实参顶层const作用于对象本身，和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。所以：1void fcn(const int i) 调用时，因为顶层const被忽略，所以可以传入常量和非常量，同时，因为忽略顶层const的问题：12void fcn(const int i) &#123;&#125;void fcn(int i) &#123;&#125; 虽然C++支持函数重载，但是由于忽略了顶层const的关系，这样属于重复定义了该函数。 数组形参1、普通数组形参因为数组不允许被拷贝以及使用数组时通常会将其转化为指针。因此当我们向函数传递一个数组时，实际上传递的是指向数组首元素的指针。1234//虽然形式不同，但是这三个print函数是等价的，每个函数都有一个const int*类型的形参void print(const int*);void print(const int[]);void print(const int[10]); //此处的10表示我们期望数组含有多少元素，实际不一定 如果这样定义三个函数，编译器会报错，因为重复定义了。 2、数组引用形参C++允许将变量定义成数组的引用，基于此，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，用法如下:12void print(int (&amp;arr)[10]); //&amp;arr两端的括号必不可少，表示arr是具有10个整数的整型数组的引用void print(int &amp;arr[10]); //错误：将arr声明成了引用的数组 3、传递多维数组和其他数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。又因为并不存在多维数组，多维数组只是数组的数组，所以多维数组的首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分，所以不能忽略：12void print(int (*matrix)[10], int rowSize) &#123;&#125; //(*matrix)两端的括号必不可少void print(int matrix[][10], int rowSize) &#123;&#125; //与上面的定义等价 默认实参1double get_area(int a = 10, int b = 10); 如上面的代码中，每个形参都提供了一个默认实参，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。因为get_area函数为它的所有形参都提供了默认实参，所以我们可以用0、1、2个实参来调用该函数：123area = get_area();area = get_area(1); //等价于get_area(1, 10)area = get_area(11, 11); //等价于get_area(11, 11)； 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参(靠右侧位置)，所以只能省略尾部的实参。 函数的返回值1、没有返回值的函数没有返回值的函数只能存在于返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。 2、有返回值的函数返回类型不是void的函数内的每一条return语句必须返回一个与分会类型相同类型的，或者是能隐式地转换成函数的返回类型的值。 3、值的返回的方式返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。注意：不要返回局部对象的引用或者指针 4、引用返回左值函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。 5、返回数组指针同样，因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用，但是由于返回数组的指针或引用的写法太过复杂，推荐使用尾置返回类型。（之后另开博客介绍） 函数重载1、重载函数的定义如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为函数重载(overload)。这些函数接受的形参类型不一样，但是执行的操作类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。对于重载的函数，它们应该在形参数量或形参类型上有所不同。1、不允许两个函数出了返回类型外其他所有的要素都相同，若如此，则第二个函数的声明是错误的。2、虽然两个形参列表看起来不一样，但其实是一样的，如下：12int lookup(const int&amp; a);int lookup(const int&amp;); //虽然一个形参有名字，一个没有，但其实一样 123typedef Phone Telnoint lookup(const Phone&amp;);int lookup(const Telno&amp;); //Telno和Phone类型相同 12int lookup(int);int lookup(const int); 拥有顶层const的形参无法和另一个没有顶层const的形参区分开来12int lookup(int&amp;);int lookup(const int&amp;); 底层const可以被区分 2、重载函数的调用编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较结果决定调用哪个函数，这个过程叫做函数匹配(function matching)或重载确定(overload resolution)，下面会着重介绍。调用重载函数的三种结果：1、编译器找到一个与实参最佳匹配(best match)的函数，并生成调用该函数的代码。2、找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配(no match)的错误信息。3、有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用(ambiguous call)。 内联函数将函数指定为内联函数(inline)，通常就是将它在每个调用点上“内联地”展开。1234incline const string &amp;shorterString(const string &amp;s1, const string &amp;s2) &#123; return s1.size() &lt;= s2.size() ? s1: s2;&#125; 该内联函数在调用的时候：1cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl; 将在编译过程中展开成类似于下面的形式：1cout &lt;&lt; s1.size() &lt;= s2.size() ? s1: s2 &lt;&lt; endl; 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 函数匹配1、选定本次调用对应的重载函数集，集合中的函数称为候选函数(candidate function)。候选函数有两个特征：一是与被调用的函数同名，二是其声明在调用点可见。2、考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数(viable function)。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。3、寻找最佳匹配（如果存在的话），从可行函数中选择与本次调用最匹配的函数。原则是实参类型与形参类型越接近，匹配的越好。含有多个形参的函数匹配情况比较复杂，如果出现： 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。 至少有一个实参的匹配优于其他可行函数提供的匹配。 如果在检查了所有实参之后没有一个函数“脱颖而出”，则该调用是二义性调用。 实参类型转换优先级1、精确匹配，包括以下情况： 实参类型和形参类型相同 实参从数组类型或函数类型转换成相应的指针类型 向实参添加顶层const或者从实参中删除顶层const 2、通过const转换实现的匹配3、通过类型提升实现的匹配4、通过算术类型转换或指针转换实现的匹配5、通过类类型转换实现的匹配 函数指针函数指针声明和定义函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。1bool lengthCompare(const string &amp;, const string &amp;); 该函数的类型是bool(const string &amp;, const string &amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：1bool (*pf)(const string &amp;, const string &amp;); //*pf必须要加括号，否则表示名为pf，返回值为bool*的函数 函数指针的使用当我们将函数名作为一个值使用时，该函数自动地转换成指针。12pf = lengthCompare; //pf指向名为lengthCompare的函数pf = &amp;lengthCompare; //等价的赋值语句，取地址符是可选的 此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。在指向不同函数类型的指针间不存在转换规则，必须精确匹配 函数指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上确实当成指针使用：1234void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); //第三个参数会自动转换成指向函数的指针void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;， const string &amp;));//等价声明","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"随笔_","date":"2017-03-10T15:28:23.000Z","path":"2017/03/10/2017年03月10日23-27-37/","text":"Welcome to my blog, enter password to read. Decrypt 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","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"C++中const的用法","date":"2017-03-10T04:30:45.000Z","path":"2017/03/10/const/","text":"const变量const又叫做const限定符，用关键字const对变量的类型加以限定，可以使得变量的值不能被改变。 123const int i = 1; //正确：编译时初始化const int i = get_size(); //正确：运行时初始化const int k; //错误：k是一个未经初始化的常量 没有初始化的常量变量编译错误其实很好理解，因为经过const限定之后变量的值已经无法改变，如果没有初始化那么这个变量的值不确定，且之后其值不能被改变。 const引用const引用称为对常量的引用，简称为“常量引用”,顾名思义，就是这个对象是一个引用，而且这个对象经过const限定符作用之后，对象的值不能被改变。12345678int main() &#123; const int c1 = 10; const int &amp;r1 = c1; int c2 = 4; const int &amp;r2 = c2; c2 = 5; cout &lt;&lt; r2 &lt;&lt; endl;&#125; 如上所示，常量引用r1,r2是一个常量，而同时，因为const的限制，r1和r2的值不能改变，所以通过r1和r2修改c1和c2的值也就不可能，但是c2因为没有const的限制，可以通过c2修改自身的值。 引用的类型必须与其引用对象的类型一致，但存在例外。一种则是允许常量引用绑定一个非常量的对象，但是不能通过该常量引用改变绑定对象的值，此种情况上面已经出现，不在赘述。另一种是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化为引用的类型即可。12double dval = 3.14;const int &amp;ri = dval; 上述代码是合法的操作c机制是12const int temp = dval;const int &amp;ri = temp; 也就是先将dval转化为整型，注意，其中的temp是临时量，所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果临时创建的一个未命名的对象。而如果ri不是常量，即：12double dval = 3.14;int &amp;r1 = dval; 此时编译器会报错，错误如下：12error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’int &amp;r1 = dval; 指针和const与引用一样，也可以令指针指向常量或非常量，类似于常量引用，指向常量的指针（不是常量指针）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：1234const double pi = 3.14;double *ptr = &amp;pi; //错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个常量*cptr = 42; //错误：不能给*cptr赋值 同样，指针的类型必须与其所指对象的类型一致，但是与引用一样，存在例外，允许一个指向常量的指针指向一个非常量的对象：12double dval = 3.14;const double *cptr = &amp;dval; //不能通过cptr改变dval的值 指针是对象而引用不是，所以允许把指针本身定为常量。常量指针必须初始化，一旦初始化完成，则指针的值不能被修改。1234int errNumb = 0;int *const curErr = &amp;errNumb;const double pi = 3.14;const double *const pip = &amp;pi; 将号放在const关键字之前用以说明指针是一个常量，不变的是指针本身的值而非指向的那个值。从右向左阅读解析，如上面代码第二行中，离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是，意思是curErr是一个常量指针。最后，声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。同理，我们可以看出pip是一个常量指针，指向的对象是一个双精度浮点型常量。 指向常量的指针和常量指针的对比指向常量的指针是指指针指向的值是一个常量（存在上述的例外），这就说明指针的值是可以被改变的，而常量指针是指指针本身是一个常量，但是指针指向的值不一定是常量。 顶层const指针本身是不是常量以及指针所指的是不是一个常量是两个相互独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用；底层const则与指针和引用等复合类型的基本类型部分有关。123456int i = 0;int *const pl = &amp;i; //顶层const int ci = 42; //顶层const int *p2 = &amp;ci; //底层const int *const p3 = p2; //左边是底层，右边是顶层const int &amp;r = ci; //用于声明引用的const都是底层const 常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：1234const int max_files = 20; //是常量表达式const int limit = max_files + 1; //是常量表达式int staff_size = 27; //不是常量表达式，因为只是int类型const int sz = get_size(); //不是，sz的值要到运行时确定","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"C和C++中声明和定义的区别","date":"2017-03-09T16:07:31.000Z","path":"2017/03/10/test-1/","text":"声明使得名字为程序所知，而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字，在这一点上定义与声明相同，然而定义还申请了存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量123extern int i； //声明i而不是定义iint j; //声明并且定义了j 任何包含了显式初始化的声明即成为定义。 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。1234567#include &lt;iostream&gt;using namespace std;int main() &#123; extern int i = 3;&#125; 123error: ‘i’ has both ‘extern’ and initializerextern int i = 3; ^ 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到变量的文件必须对其进行声明，却绝对不能重复定义。 正确的用法如下： test.hpp12345#include &lt;iostream&gt;using namespace std;int i = 2; test.cpp12345678910111213#include &lt;iostream&gt;#include \"test.hpp\"using namespace std;extern int i;int main() &#123; cout &lt;&lt; i; i = 1; cout &lt;&lt; endl &lt;&lt; i; return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]